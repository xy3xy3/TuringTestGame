{% extends "base.html" %}

{% block title %}游戏进行中 - 图灵测试{% endblock %}

{% block content %}
<div class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4">
  <div class="max-w-4xl mx-auto">
    <!-- 顶部信息栏 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4 mb-4">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-xl font-bold text-white">第 <span id="round-number">{{ current_round }}</span> 轮</h1>
          <p class="text-purple-200 text-sm">房间号：{{ room.room_id }}</p>
        </div>
        <div class="text-right">
          <div id="phase-display" class="text-lg font-semibold text-white">等待中...</div>
          <div id="countdown" class="text-3xl font-bold text-purple-400">--</div>
        </div>
      </div>
      
      <!-- 进度条 -->
      <div class="mt-3 h-1.5 bg-white/20 rounded-full overflow-hidden">
        <div id="progress-bar" class="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-1000" style="width: 0%"></div>
      </div>
    </div>

    <!-- 玩家信息栏 -->
    <div class="grid grid-cols-2 gap-4 mb-4">
      <!-- 提问者 -->
      <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4">
        <p class="text-purple-200 text-sm mb-1">提问者</p>
        <div class="flex items-center gap-2">
          <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white text-sm font-bold" id="interrogator-avatar">
            ?
          </div>
          <span class="text-white font-medium" id="interrogator-name">等待中...</span>
        </div>
      </div>
      
      <!-- 被测者 -->
      <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4">
        <p class="text-purple-200 text-sm mb-1">被测者</p>
        <div class="flex items-center gap-2">
          <div class="w-8 h-8 rounded-full bg-pink-500 flex items-center justify-center text-white text-sm font-bold" id="subject-avatar">
            ?
          </div>
          <span class="text-white font-medium" id="subject-name">等待中...</span>
        </div>
      </div>
    </div>

    <!-- 问答区域 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-6 mb-4 min-h-[300px]">
      <!-- 问题显示 -->
      <div id="question-area" class="mb-6">
        <p class="text-purple-200 text-sm mb-2">问题：</p>
        <div class="bg-blue-500/20 rounded-xl p-4">
          <p class="text-white text-lg" id="question-text">等待提问...</p>
        </div>
      </div>

      <!-- 回答显示 -->
      <div id="answer-area">
        <p class="text-purple-200 text-sm mb-2">回答：</p>
        <div id="answer-content" class="bg-pink-500/20 rounded-xl p-4 hidden">
          <p class="text-white text-lg" id="answer-text">等待回答...</p>
          <p class="text-purple-300 text-sm mt-2" id="answer-type-label"></p>
        </div>
        
        <!-- 加载动画 -->
        <div id="loading-area" class="text-center py-8">
          <div class="inline-flex items-center gap-2 text-purple-300">
            <i class="fa-solid fa-circle-notch fa-spin text-2xl"></i>
            <span>对方正在输入...</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 操作区域 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-6">
      <!-- 提问者输入 -->
      <div id="question-input-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请输入你的问题：</p>
        <div class="flex gap-2">
          <input type="text" id="question-input" class="input flex-1" placeholder="输入问题..." 
            onkeypress="if(event.key==='Enter') submitQuestion()" />
          <button class="btn-primary px-6" onclick="submitQuestion()">提问</button>
        </div>
      </div>

      <!-- 被测者选择 -->
      <div id="answer-choice-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请选择回答方式：</p>
        <div class="flex gap-4">
          <button class="flex-1 bg-gradient-to-r from-green-500 to-emerald-500 text-white font-bold py-4 px-6 rounded-xl hover:from-green-600 hover:to-emerald-600 transition-all" onclick="showHumanAnswer()">
            <i class="fa-solid fa-user mr-2"></i>亲自回答
          </button>
          <button class="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 px-6 rounded-xl hover:from-purple-600 hover:to-pink-600 transition-all" onclick="submitAIAnswer()">
            <i class="fa-solid fa-robot mr-2"></i>AI 代答
          </button>
        </div>
      </div>

      <!-- 被测者手动输入 -->
      <div id="answer-input-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请输入你的回答：</p>
        <div class="flex gap-2">
          <textarea id="answer-input" class="input flex-1 h-24" placeholder="输入回答..."></textarea>
          <button class="btn-primary px-6" onclick="submitHumanAnswer()">提交</button>
        </div>
      </div>

      <!-- 投票区域 -->
      <div id="vote-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">判断这个回答是：</p>
        <div class="flex gap-4">
          <button class="flex-1 bg-blue-500/20 hover:bg-blue-500/40 text-blue-400 font-bold py-3 px-4 rounded-xl border border-blue-500/30 transition-all" onclick="submitVote('human')">
            <i class="fa-solid fa-user mr-2"></i>真人
          </button>
          <button class="flex-1 bg-red-500/20 hover:bg-red-500/40 text-red-400 font-bold py-3 px-4 rounded-xl border border-red-500/30 transition-all" onclick="submitVote('ai')">
            <i class="fa-solid fa-robot mr-2"></i>AI
          </button>
          <button class="flex-1 bg-gray-500/20 hover:bg-gray-500/40 text-gray-400 font-bold py-3 px-4 rounded-xl border border-gray-500/30 transition-all" onclick="submitVote('skip')">
            <i class="fa-solid fa-forward mr-2"></i>跳过
          </button>
        </div>
      </div>

      <!-- 等待区域 -->
      <div id="wait-area" class="text-center py-8">
        <p class="text-purple-300">请等待其他玩家操作...</p>
      </div>
    </div>

    <!-- 玩家得分 -->
    <div class="mt-4 bg-white/10 backdrop-blur-md rounded-2xl p-4">
      <div class="flex items-center justify-between mb-2">
        <p class="text-purple-200 text-sm">玩家得分：</p>
        <button onclick="showScoreRules()" class="text-purple-300 hover:text-white text-sm underline">
          <i class="fa-solid fa-circle-question mr-1"></i>得分规则
        </button>
      </div>
      <div class="flex flex-wrap gap-2" id="score-board">
        <!-- 玩家得分由 SSE 更新 -->
      </div>
    </div>
  </div>
</div>

<!-- 得分规则弹窗 -->
<div id="score-rules-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
  <div class="bg-slate-800 rounded-2xl max-w-md w-full p-6 border border-white/10">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-xl font-bold text-white">得分规则</h3>
      <button onclick="hideScoreRules()" class="text-gray-400 hover:text-white">
        <i class="fa-solid fa-xmark text-xl"></i>
      </button>
    </div>
    <div class="space-y-4 text-gray-300 text-sm max-h-[60vh] overflow-y-auto">
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-gavel text-blue-400 mr-2"></i>陪审团（投票者）
        </h4>
        <ul class="space-y-1 ml-6 list-disc">
          <li>猜对回答类型：<span class="text-green-400 font-bold">+50分</span></li>
          <li>猜错回答类型：<span class="text-red-400 font-bold">-30分</span></li>
          <li>选择跳过：<span class="text-gray-400">0分</span></li>
        </ul>
      </div>
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-user-secret text-pink-400 mr-2"></i>被测者（回答者）
        </h4>
        <ul class="space-y-1 ml-6 list-disc">
          <li>使用AI回答并骗过1人：<span class="text-green-400 font-bold">+100分/人</span></li>
          <li>完美伪装（所有人猜错）：<span class="text-green-400 font-bold">额外+200分</span></li>
          <li>使用真人回答：无额外得分</li>
        </ul>
      </div>
      <div class="bg-white/5 rounded-lg p-3 text-xs text-gray-400">
        <p><i class="fa-solid fa-lightbulb text-yellow-400 mr-1"></i>小贴士：作为被测者，使用AI回答并成功欺骗更多玩家可以获得更高分数！</p>
      </div>
    </div>
  </div>
</div>

<script>
const roomId = '{{ room.id }}';
const playerId = '{{ player_id }}';
let currentRound = {{ current_round }};
let currentPhase = 'waiting';
let currentRoundId = '';

// 倒计时相关
let countdownRemaining = 0;
let countdownTotal = 30;  // 当前阶段总时长
let countdownInterval = null;

// SSE 连接
let eventSource = null;

// 启动本地倒计时
function startLocalCountdown(remaining, total) {
  // 如果本地倒计时已经在运行，且时间差小于2秒，不需要重新同步
  // 这样可以避免 SSE 每秒推送导致的"跳来跳去"
  if (countdownInterval && Math.abs(countdownRemaining - remaining) < 2) {
    return;
  }
  
  countdownRemaining = remaining;
  countdownTotal = total || remaining;
  
  // 清除之前的定时器
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
  
  // 立即更新显示
  updateCountdownDisplay();
  
  // 每秒递减
  countdownInterval = setInterval(() => {
    countdownRemaining = Math.max(0, countdownRemaining - 1);
    updateCountdownDisplay();
    
    if (countdownRemaining <= 0) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }
  }, 1000);
}

// 更新倒计时显示
function updateCountdownDisplay() {
  document.getElementById('countdown').textContent = countdownRemaining;
  document.getElementById('progress-bar').style.width = `${(countdownRemaining / countdownTotal) * 100}%`;
}

// 停止本地倒计时
function stopLocalCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
}

function connectSSE() {
  eventSource = new EventSource(`/game/${roomId}/events`);

  // 游戏开始事件（第一回合）
  eventSource.addEventListener('game_start', (e) => {
    const data = JSON.parse(e.data);
    currentRound = data.round_number;
    currentRoundId = data.round_id || '';
    document.getElementById('round-number').textContent = data.round_number;
    document.getElementById('interrogator-name').textContent = data.interrogator_nickname;
    document.getElementById('interrogator-avatar').textContent = data.interrogator_nickname[0];
    document.getElementById('subject-name').textContent = data.subject_nickname;
    document.getElementById('subject-avatar').textContent = data.subject_nickname[0];

    // 更新角色状态
    isCurrentInterrogator = (data.interrogator_nickname === myNickname);
    isCurrentSubject = (data.subject_nickname === myNickname);

    // 重置显示
    document.getElementById('question-text').textContent = '等待提问...';
    document.getElementById('answer-text').textContent = '等待回答...';
    document.getElementById('answer-content').classList.add('hidden');
    document.getElementById('loading-area').classList.add('hidden');

    updatePhaseDisplay('questioning');
  });

  // 新回合事件（后续轮次）
  eventSource.addEventListener('new_round', (e) => {
    const data = JSON.parse(e.data);
    currentRound = data.round_number;
    currentRoundId = data.round_id || '';
    document.getElementById('round-number').textContent = data.round_number;
    document.getElementById('interrogator-name').textContent = data.interrogator_nickname;
    document.getElementById('interrogator-avatar').textContent = data.interrogator_nickname[0];
    document.getElementById('subject-name').textContent = data.subject_nickname;
    document.getElementById('subject-avatar').textContent = data.subject_nickname[0];

    // 更新角色状态
    isCurrentInterrogator = (data.interrogator_nickname === myNickname);
    isCurrentSubject = (data.subject_nickname === myNickname);

    // 重置显示
    document.getElementById('question-text').textContent = '等待提问...';
    document.getElementById('answer-text').textContent = '等待回答...';
    document.getElementById('answer-content').classList.add('hidden');
    document.getElementById('loading-area').classList.add('hidden');

    updatePhaseDisplay('questioning');
  });

  eventSource.addEventListener('new_question', (e) => {
    const data = JSON.parse(e.data);
    document.getElementById('question-text').textContent = data.question;
    updatePhaseDisplay('answering');
  });

  eventSource.addEventListener('answer_submitted', (e) => {
    document.getElementById('loading-area').classList.remove('hidden');
    document.getElementById('answer-content').classList.add('hidden');
  });

  eventSource.addEventListener('new_answer', (e) => {
    const data = JSON.parse(e.data);
    document.getElementById('loading-area').classList.add('hidden');
    document.getElementById('answer-content').classList.remove('hidden');
    document.getElementById('answer-text').textContent = data.answer;
    // 隐藏回答类型标签（双方都无法看到是否是 AI 回答）
    document.getElementById('answer-type-label').classList.add('hidden');
    updatePhaseDisplay('voting');
  });

  eventSource.addEventListener('countdown', (e) => {
    const data = JSON.parse(e.data);
    // 使用服务器时间同步本地倒计时，避免跳来跳去
    // 根据当前阶段设置总时长
    let totalTime = 30;  // 默认
    if (data.phase === 'questioning') totalTime = 30;
    else if (data.phase === 'answering') totalTime = 45;
    else if (data.phase === 'voting') totalTime = 15;
    else if (data.phase === 'setup') totalTime = 60;
    
    // 同步剩余时间并启动本地倒计时
    startLocalCountdown(data.remaining, totalTime);
  });

  eventSource.addEventListener('round_result', (e) => {
    const data = JSON.parse(e.data);
    updateScoreBoard(data.player_scores);
    updatePhaseDisplay('revealed');
  });

  eventSource.addEventListener('game_over', (e) => {
    const data = JSON.parse(e.data);
    window.location.href = `/game/${roomId}/result?data=` + encodeURIComponent(JSON.stringify(data));
  });

  eventSource.onerror = () => {
    console.log('SSE connection error, reconnecting...');
  };
}

function updatePhaseDisplay(phase) {
  currentPhase = phase;
  
  // 阶段变化时停止本地倒计时（结果揭晓阶段不需要倒计时）
  if (phase === 'revealed') {
    stopLocalCountdown();
  }
  
  const phaseNames = {
    'questioning': '提问阶段',
    'answering': '回答阶段',
    'voting': '投票阶段',
    'revealed': '结果揭晓'
  };
  document.getElementById('phase-display').textContent = phaseNames[phase] || phase;

  // 显示/隐藏操作区域
  document.getElementById('question-input-area').classList.add('hidden');
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('answer-input-area').classList.add('hidden');
  document.getElementById('vote-area').classList.add('hidden');
  document.getElementById('wait-area').classList.add('hidden');

  if (phase === 'questioning') {
    if (isCurrentInterrogator) {
      document.getElementById('question-input-area').classList.remove('hidden');
    } else {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '等待提问者提问...';
    }
  } else if (phase === 'answering') {
    if (isCurrentSubject) {
      document.getElementById('answer-choice-area').classList.remove('hidden');
    } else {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '等待被测者回答...';
    }
  } else if (phase === 'voting') {
    // 被测者不能投票
    if (isCurrentSubject) {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '你是被测者，等待投票结果...';
    } else {
      document.getElementById('vote-area').classList.remove('hidden');
    }
  } else if (phase === 'revealed') {
    document.getElementById('wait-area').classList.remove('hidden');
    document.getElementById('wait-area').querySelector('p').textContent = '结果已揭晓，等待下一轮...';
  } else {
    document.getElementById('wait-area').classList.remove('hidden');
  }
}

function updateScoreBoard(playerScores) {
  const board = document.getElementById('score-board');
  board.innerHTML = '';
  // playerScores 是数组格式：[{id, nickname, score}, ...]
  for (const player of playerScores) {
    const badge = document.createElement('span');
    badge.className = 'px-3 py-1 bg-white/10 rounded-full text-white text-sm';
    badge.textContent = `${player.nickname}: ${player.score}分`;
    board.appendChild(badge);
  }
}

async function submitQuestion() {
  const input = document.getElementById('question-input');
  const question = input.value.trim();
  if (!question) return;

  // 立即隐藏提问输入区域，防止重复点击
  document.getElementById('question-input-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交问题，等待被测者回答...';

  await fetch(`/game/${roomId}/question`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `question=${encodeURIComponent(question)}&round_id=${encodeURIComponent(currentRoundId)}`
  });

  input.value = '';
}

// 显示得分规则弹窗
function showScoreRules() {
  document.getElementById('score-rules-modal').classList.remove('hidden');
}

// 隐藏得分规则弹窗
function hideScoreRules() {
  document.getElementById('score-rules-modal').classList.add('hidden');
}

// 点击弹窗背景关闭
document.addEventListener('click', function(e) {
  const modal = document.getElementById('score-rules-modal');
  if (e.target === modal) {
    hideScoreRules();
  }
});

function showHumanAnswer() {
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('answer-input-area').classList.remove('hidden');
}

async function submitAIAnswer() {
  // 立即隐藏选择区域，防止重复点击
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已选择AI回答，等待生成...';

  await fetch(`/game/${roomId}/answer`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `answer_type=ai&answer_content=&round_id=${encodeURIComponent(currentRoundId)}`
  });
}

async function submitHumanAnswer() {
  const input = document.getElementById('answer-input');
  const answer = input.value.trim();
  if (!answer) return;

  // 立即隐藏输入区域，防止重复点击
  document.getElementById('answer-input-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交回答，等待投票...';

  await fetch(`/game/${roomId}/answer`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `answer_type=human&answer_content=${encodeURIComponent(answer)}&round_id=${encodeURIComponent(currentRoundId)}`
  });

  input.value = '';
}

async function submitVote(vote) {
  await fetch(`/game/${roomId}/vote`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `vote=${vote}&round_id=${encodeURIComponent(currentRoundId)}`
  });
  
  document.getElementById('vote-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已投票，等待其他玩家...';
}

// 当前玩家角色
let isCurrentInterrogator = false;
let isCurrentSubject = false;
let myNickname = '';

// 页面加载时获取当前回合状态（用于刷新页面后恢复状态）
async function initGameState() {
  try {
    console.log('Initializing game state...');

    // 先获取房间状态以确定当前玩家昵称
    const roomRes = await fetch(`/game/api/${roomId}/state`);
    const roomData = await roomRes.json();
    console.log('Room state:', roomData);

    if (roomData.success && roomData.players) {
      const me = roomData.players.find(p => p.id === playerId);
      if (me) {
        myNickname = me.nickname;
        console.log('My nickname:', myNickname);
      } else {
        console.warn('Player not found in room');
      }
      // 更新玩家得分显示
      const playerScores = roomData.players.map(p => ({
        id: p.id,
        nickname: p.nickname,
        score: p.score || 0
      }));
      updateScoreBoard(playerScores);
    }

    // 获取当前回合
    const res = await fetch(`/game/api/${roomId}/round`);
    const data = await res.json();
    console.log('Round data:', data);

    if (data.success && data.round) {
      const round = data.round;
      currentRoundId = round.id;
      currentRound = round.round_number;

      // 更新显示
      document.getElementById('round-number').textContent = round.round_number;
      document.getElementById('interrogator-name').textContent = round.interrogator_nickname;
      document.getElementById('interrogator-avatar').textContent = round.interrogator_nickname[0];
      document.getElementById('subject-name').textContent = round.subject_nickname;
      document.getElementById('subject-avatar').textContent = round.subject_nickname[0];

      // 判断当前玩家角色
      isCurrentInterrogator = (round.interrogator_nickname === myNickname);
      isCurrentSubject = (round.subject_nickname === myNickname);
      console.log('Role - Interrogator:', isCurrentInterrogator, 'Subject:', isCurrentSubject);

      // 更新问题和回答显示
      if (round.question) {
        document.getElementById('question-text').textContent = round.question;
      }

      if (round.answer) {
        document.getElementById('loading-area').classList.add('hidden');
        document.getElementById('answer-content').classList.remove('hidden');
        document.getElementById('answer-text').textContent = round.answer;
        // 隐藏回答类型标签（双方都无法看到是否是 AI 回答）
        document.getElementById('answer-type-label').classList.add('hidden');
      }

      // 根据状态更新阶段显示
      updatePhaseDisplay(round.status);
    } else {
      console.warn('No round data available:', data.error || 'Unknown error');
      // 显示等待信息
      document.getElementById('phase-display').textContent = '等待游戏开始...';
    }
  } catch (e) {
    console.error('Failed to init game state:', e);
  }
}

// 页面加载时先获取状态，再连接 SSE
initGameState().then(() => {
  connectSSE();
});
</script>
{% endblock %}
