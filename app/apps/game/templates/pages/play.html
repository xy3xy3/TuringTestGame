{% extends "base.html" %}

{% block title %}游戏进行中 - 图灵测试{% endblock %}

{% block content %}
<div class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 px-4 pb-4 pt-20 md:p-4">
  <!-- 移动端固定倒计时条：滚动时始终可见，避免错过提问/回答/投票时限。 -->
  <div class="fixed inset-x-0 z-50 px-3 md:hidden pointer-events-none" style="top: calc(env(safe-area-inset-top, 0px) + 8px);">
    <div class="mx-auto max-w-md rounded-xl border border-white/20 bg-slate-900/80 px-3 py-2 backdrop-blur-md shadow-lg">
      <div class="flex items-center justify-between text-xs text-purple-100">
        <span class="font-medium">第 <span id="mobile-round-number">{{ current_round }}</span>/<span id="mobile-total-rounds">{{ room.total_rounds }}</span> 回合 · <span id="mobile-phase-display">等待中...</span></span>
        <span class="text-base font-bold text-purple-200"><span id="mobile-countdown">--</span>s</span>
      </div>
      <div class="mt-2 h-1.5 bg-white/20 rounded-full overflow-hidden">
        <div id="mobile-progress-bar" class="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-1000" style="width: 0%"></div>
      </div>
    </div>
  </div>
  <div class="max-w-4xl mx-auto">
    <!-- 顶部信息栏 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4 mb-4">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-xl font-bold text-white">第 <span id="round-number">{{ current_round }}</span>/<span id="total-rounds">{{ room.total_rounds }}</span> 回合</h1>
          <p class="text-purple-200 text-sm">房间号：{{ room.room_id }}</p>
        </div>
        <div class="text-right">
          <div id="phase-display" class="text-lg font-semibold text-white">等待中...</div>
          <div id="countdown" class="text-3xl font-bold text-purple-400">--</div>
          <div class="mt-2 flex items-center justify-end gap-2 text-xs">
            <span id="connection-indicator" class="inline-flex items-center gap-1 rounded-full border border-white/20 bg-white/10 px-2 py-1 text-purple-100">
              <span id="connection-dot" class="h-2 w-2 rounded-full bg-green-400"></span>
              <span id="connection-text">实时连接正常</span>
            </span>
            <button
              id="reconnect-btn"
              type="button"
              class="rounded-full border border-white/20 bg-white/10 px-2 py-1 text-purple-100 transition hover:bg-white/20"
              onclick="forceReconnectSSE('manual')"
            >
              立即重连
            </button>
          </div>
        </div>
      </div>
      
      <!-- 进度条 -->
      <div class="mt-3 h-1.5 bg-white/20 rounded-full overflow-hidden">
        <div id="progress-bar" class="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-1000" style="width: 0%"></div>
      </div>
    </div>

    <!-- 玩家信息栏 -->
    <div class="grid grid-cols-2 gap-4 mb-4">
      <!-- 提问者 -->
      <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4">
        <p class="text-purple-200 text-sm mb-1">提问者</p>
        <div class="flex items-center gap-2">
          <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white text-sm font-bold" id="interrogator-avatar">
            ?
          </div>
          <span class="text-white font-medium" id="interrogator-name">等待中...</span>
        </div>
      </div>
      
      <!-- 被测者 -->
      <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4">
        <p class="text-purple-200 text-sm mb-1">被测者</p>
        <div class="flex items-center gap-2">
          <div class="w-8 h-8 rounded-full bg-pink-500 flex items-center justify-center text-white text-sm font-bold" id="subject-avatar">
            ?
          </div>
          <span class="text-white font-medium" id="subject-name">等待中...</span>
        </div>
      </div>
    </div>

    <!-- 问答区域 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-6 mb-4 min-h-[300px]">
      <!-- 问题显示 -->
      <div id="question-area" class="mb-6">
        <p class="text-purple-200 text-sm mb-2">问题：</p>
        <div class="bg-blue-500/20 rounded-xl p-4">
          <p class="text-white text-lg" id="question-text">等待提问...</p>
        </div>
      </div>

      <!-- 回答显示 -->
      <div id="answer-area">
        <p class="text-purple-200 text-sm mb-2">回答：</p>
        <div id="answer-content" class="bg-pink-500/20 rounded-xl p-4 hidden">
          <p class="text-white text-lg" id="answer-text">等待回答...</p>
          <p class="text-purple-300 text-sm mt-2" id="answer-type-label"></p>
        </div>
        
        <!-- 加载动画 -->
        <div id="loading-area" class="text-center py-8">
          <div class="inline-flex items-center gap-2 text-purple-300">
            <i class="fa-solid fa-circle-notch fa-spin text-2xl"></i>
            <span>对方正在输入...</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 操作区域 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-6">
      <!-- 提问者输入 -->
      <div id="question-input-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请输入你的问题：</p>
        <div class="flex gap-2">
          <input type="text" id="question-input" class="input flex-1" placeholder="输入问题..." 
            onkeypress="if(event.key==='Enter') submitQuestion()" />
          <button class="btn-primary px-6" onclick="submitQuestion()">提问</button>
        </div>
      </div>

      <!-- 被测者选择 -->
      <div id="answer-choice-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请选择回答方式：</p>
        <div class="flex gap-4">
          <button class="flex-1 bg-gradient-to-r from-green-500 to-emerald-500 text-white font-bold py-4 px-6 rounded-xl hover:from-green-600 hover:to-emerald-600 transition-all" onclick="showHumanAnswer()">
            <i class="fa-solid fa-user mr-2"></i>亲自回答
          </button>
          <button class="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 px-6 rounded-xl hover:from-purple-600 hover:to-pink-600 transition-all" onclick="submitAIAnswer()">
            <i class="fa-solid fa-robot mr-2"></i>AI 代答
          </button>
        </div>
      </div>

      <!-- 被测者手动输入 -->
      <div id="answer-input-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请输入你的回答：</p>
        <div class="flex gap-2">
          <textarea id="answer-input" class="input flex-1 h-24" placeholder="输入回答..."></textarea>
          <button class="btn-primary px-6" onclick="submitHumanAnswer()">提交</button>
        </div>
      </div>

      <!-- 投票区域 -->
      <div id="vote-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">判断这个回答是：</p>
        <div class="flex gap-4">
          <button class="flex-1 bg-blue-500/20 hover:bg-blue-500/40 text-blue-400 font-bold py-3 px-4 rounded-xl border border-blue-500/30 transition-all" onclick="submitVote('human')">
            <i class="fa-solid fa-user mr-2"></i>真人
          </button>
          <button class="flex-1 bg-red-500/20 hover:bg-red-500/40 text-red-400 font-bold py-3 px-4 rounded-xl border border-red-500/30 transition-all" onclick="submitVote('ai')">
            <i class="fa-solid fa-robot mr-2"></i>AI
          </button>
          <button class="flex-1 bg-gray-500/20 hover:bg-gray-500/40 text-gray-400 font-bold py-3 px-4 rounded-xl border border-gray-500/30 transition-all" onclick="submitVote('skip')">
            <i class="fa-solid fa-forward mr-2"></i>跳过
          </button>
        </div>
      </div>

      <!-- 等待区域 -->
      <div id="wait-area" class="text-center py-8">
        <p class="text-purple-300">请等待其他玩家操作...</p>
      </div>
    </div>

    <!-- 玩家得分 -->
    <div class="mt-4 bg-white/10 backdrop-blur-md rounded-2xl p-4">
      <div class="flex items-center justify-between mb-2">
        <p class="text-purple-200 text-sm">玩家得分：</p>
        <button onclick="showScoreRules()" class="text-purple-300 hover:text-white text-sm underline">
          <i class="fa-solid fa-circle-question mr-1"></i>得分规则
        </button>
      </div>
      <div class="flex flex-wrap gap-2" id="score-board">
        <!-- 玩家得分由 SSE 更新 -->
      </div>

      <div id="round-feedback-card" class="mt-3 hidden rounded-xl border border-white/10 bg-white/5 px-4 py-3">
        <p id="round-feedback-title" class="text-sm font-semibold text-white">本轮反馈</p>
        <p id="round-feedback-detail" class="mt-1 text-xs text-purple-200">等待本轮结算...</p>
        <p id="round-feedback-score" class="mt-2 text-sm font-bold text-purple-300">本轮得分变化：0 分</p>
      </div>
    </div>
  </div>
</div>

<!-- 得分规则弹窗 -->
<div id="score-rules-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
  <div class="bg-slate-800 rounded-2xl max-w-md w-full p-6 border border-white/10">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-xl font-bold text-white">得分规则</h3>
      <button onclick="hideScoreRules()" class="text-gray-400 hover:text-white">
        <i class="fa-solid fa-xmark text-xl"></i>
      </button>
    </div>
    <div class="space-y-4 text-gray-300 text-sm max-h-[60vh] overflow-y-auto">
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-gavel text-blue-400 mr-2"></i>投票玩家（提问者 + 陪审团）
        </h4>
        <ul class="space-y-1 ml-6 list-disc">
          <li>猜对回答类型：<span class="text-green-400 font-bold">+50分</span></li>
          <li>猜错回答类型：<span class="text-red-400 font-bold">-30分</span></li>
          <li>选择跳过：<span class="text-gray-400">0分</span></li>
        </ul>
      </div>
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-bolt text-yellow-300 mr-2"></i>附加给分机制
        </h4>
        {% if room.config.bonus_scoring_enabled %}
        <ul class="space-y-1 ml-6 list-disc">
          <li>提问者若让所有陪审团答对：<span class="text-green-400 font-bold">额外 +50分</span></li>
          <li>被测者使用 AI 回答且骗过所有陪审团：<span class="text-green-400 font-bold">额外 +50分</span></li>
          <li>被测者亲自回答且骗过所有陪审团：<span class="text-green-400 font-bold">额外 +25分</span></li>
        </ul>
        {% else %}
        <p class="text-xs text-gray-400">本局未开启附加给分机制，仅按投票结果计分。</p>
        {% endif %}
      </div>
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-user-shield text-pink-400 mr-2"></i>被测者
        </h4>
        {% if room.config.bonus_scoring_enabled %}
        <ul class="space-y-1 ml-6 list-disc">
          <li>本轮不参与投票，默认得分为 <span class="text-gray-300 font-bold">0 分</span></li>
          <li>满足附加机制条件时可获得额外加分</li>
        </ul>
        {% else %}
        <ul class="space-y-1 ml-6 list-disc">
          <li>本轮不参与投票与计分：<span class="text-gray-300 font-bold">固定 0 分</span></li>
          <li>仍正常参与回答流程，并等待其他玩家投票完成</li>
        </ul>
        {% endif %}
      </div>
      <div class="bg-white/5 rounded-lg p-3 text-xs text-gray-400">
        <p><i class="fa-solid fa-lightbulb text-yellow-400 mr-1"></i>小贴士：跳过不加减分，附加机制仅在房主开启后生效。</p>
      </div>
    </div>
  </div>
</div>

<script>
const roomId = '{{ room.id }}';
const playerId = '{{ player_id }}';
const bonusScoringEnabled = {{ "true" if room.config.bonus_scoring_enabled else "false" }};
let currentRound = {{ current_round }};
let totalRounds = {{ room.total_rounds }};
let currentPhase = 'waiting';
let currentRoundId = '';
let myLastVote = '';
const phaseDurations = {
  setup: {{ room.config.setup_duration }},
  questioning: {{ room.config.question_duration }},
  answering: {{ room.config.answer_duration }},
  voting: {{ room.config.vote_duration }},
};

// 倒计时相关
let countdownRemaining = 0;
let countdownTotal = phaseDurations.questioning;  // 当前阶段总时长
let countdownInterval = null;

// 草稿同步相关
let questionDraftTimer = null;
let answerDraftTimer = null;
let lastQuestionDraft = '';
let lastAnswerDraft = '';

// SSE 连接
let eventSource = null;
let hasSSEConnected = false;
let sseReconnectTimer = null;
let sseReconnectAttempts = 0;
let stateSyncTimer = null;
let isSyncingGameState = false;

function mapPhaseToBgmStage(phase) {
  const phaseKey = String(phase || '').trim().toLowerCase();
  if (phaseKey === 'questioning') return 'playing_questioning';
  if (phaseKey === 'answering') return 'playing_answering';
  if (phaseKey === 'voting') return 'playing_voting';
  return '';
}

function applyBgmForPhase(phase) {
  const stage = mapPhaseToBgmStage(phase);
  if (!stage || typeof window.setGameBgmStage !== 'function') return;
  window.setGameBgmStage(stage);
}

function applyBgmForRoundResult(result) {
  if (typeof window.setGameBgmStage !== 'function') return;
  const scores = result?.scores || {};
  const delta = Number(scores[playerId] || 0);
  if (delta > 0) {
    window.setGameBgmStage('playing_scored');
    return;
  }
  if (delta < 0) {
    window.setGameBgmStage('playing_penalty');
    return;
  }
  window.setGameBgmStage('playing_skipped');
}

// 启动本地倒计时
function startLocalCountdown(remaining, total) {
  // 如果本地倒计时已经在运行，且时间差小于2秒，不需要重新同步
  // 这样可以避免 SSE 每秒推送导致的"跳来跳去"
  if (countdownInterval && Math.abs(countdownRemaining - remaining) < 2) {
    return;
  }
  
  countdownRemaining = remaining;
  countdownTotal = total || remaining;
  
  // 清除之前的定时器
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
  
  // 立即更新显示
  updateCountdownDisplay();
  
  // 每秒递减
  countdownInterval = setInterval(() => {
    countdownRemaining = Math.max(0, countdownRemaining - 1);
    updateCountdownDisplay();
    
    if (countdownRemaining <= 0) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }
  }, 1000);
}

// 更新倒计时显示
function updateCountdownDisplay() {
  const desktopCountdown = document.getElementById('countdown');
  const mobileCountdown = document.getElementById('mobile-countdown');
  if (desktopCountdown) {
    desktopCountdown.textContent = countdownRemaining;
  }
  if (mobileCountdown) {
    mobileCountdown.textContent = countdownRemaining;
  }
  const percent = countdownTotal > 0 ? (countdownRemaining / countdownTotal) * 100 : 0;
  const desktopProgressBar = document.getElementById('progress-bar');
  const mobileProgressBar = document.getElementById('mobile-progress-bar');
  if (desktopProgressBar) {
    desktopProgressBar.style.width = `${percent}%`;
  }
  if (mobileProgressBar) {
    mobileProgressBar.style.width = `${percent}%`;
  }
}

// 停止本地倒计时
function stopLocalCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
}

// 更新顶部回合显示（第 x / y 回合）
function setRoundDisplay(roundNumber, totalRoundNumber) {
  if (Number.isFinite(Number(roundNumber))) {
    currentRound = Number(roundNumber);
    document.getElementById('round-number').textContent = String(currentRound);
    const mobileRoundNumber = document.getElementById('mobile-round-number');
    if (mobileRoundNumber) {
      mobileRoundNumber.textContent = String(currentRound);
    }
  }
  if (Number.isFinite(Number(totalRoundNumber))) {
    totalRounds = Number(totalRoundNumber);
    document.getElementById('total-rounds').textContent = String(totalRounds);
    const mobileTotalRounds = document.getElementById('mobile-total-rounds');
    if (mobileTotalRounds) {
      mobileTotalRounds.textContent = String(totalRounds);
    }
  }
}

function setPhaseDisplayText(text) {
  const normalizedText = String(text || '等待中...');
  const desktopPhaseDisplay = document.getElementById('phase-display');
  const mobilePhaseDisplay = document.getElementById('mobile-phase-display');
  if (desktopPhaseDisplay) {
    desktopPhaseDisplay.textContent = normalizedText;
  }
  if (mobilePhaseDisplay) {
    mobilePhaseDisplay.textContent = normalizedText;
  }
}

function resetDraftSyncState() {
  if (questionDraftTimer) {
    clearTimeout(questionDraftTimer);
    questionDraftTimer = null;
  }
  if (answerDraftTimer) {
    clearTimeout(answerDraftTimer);
    answerDraftTimer = null;
  }
  lastQuestionDraft = '';
  lastAnswerDraft = '';
}

async function syncDraftNow(draftType, content) {
  if (!currentRoundId) return;
  const normalizedType = String(draftType || '').trim().toLowerCase();
  if (!normalizedType) return;
  try {
    await fetch(`/game/${roomId}/draft`, {
      method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded'},
      body: `round_id=${encodeURIComponent(currentRoundId)}&draft_type=${encodeURIComponent(normalizedType)}&content=${encodeURIComponent(content || '')}`
    });
  } catch (error) {
    console.warn('草稿同步失败：', error);
  }
}

function scheduleQuestionDraftSync() {
  if (!isCurrentInterrogator || currentPhase !== 'questioning' || !currentRoundId) return;
  const questionInput = document.getElementById('question-input');
  if (!questionInput) return;

  if (questionDraftTimer) {
    clearTimeout(questionDraftTimer);
  }
  questionDraftTimer = setTimeout(async () => {
    questionDraftTimer = null;
    const draft = questionInput.value || '';
    if (draft === lastQuestionDraft) return;
    lastQuestionDraft = draft;
    await syncDraftNow('question', draft);
  }, 250);
}

function scheduleAnswerDraftSync() {
  if (!isCurrentSubject || currentPhase !== 'answering' || !currentRoundId) return;
  const answerInput = document.getElementById('answer-input');
  if (!answerInput) return;

  if (answerDraftTimer) {
    clearTimeout(answerDraftTimer);
  }
  answerDraftTimer = setTimeout(async () => {
    answerDraftTimer = null;
    const draft = answerInput.value || '';
    if (draft === lastAnswerDraft) return;
    lastAnswerDraft = draft;
    await syncDraftNow('answer', draft);
  }, 250);
}

function setConnectionStatus(status, customText = '') {
  const dot = document.getElementById('connection-dot');
  const text = document.getElementById('connection-text');
  if (!dot || !text) return;

  dot.classList.remove('bg-green-400', 'bg-yellow-400', 'bg-red-400');
  if (status === 'connected') {
    dot.classList.add('bg-green-400');
    text.textContent = customText || '实时连接正常';
    return;
  }
  if (status === 'offline') {
    dot.classList.add('bg-red-400');
    text.textContent = customText || '网络断开，等待恢复';
    return;
  }
  dot.classList.add('bg-yellow-400');
  text.textContent = customText || '连接波动，重连中...';
}

function stopStateSyncPolling() {
  if (!stateSyncTimer) return;
  clearInterval(stateSyncTimer);
  stateSyncTimer = null;
}

function startStateSyncPolling() {
  if (stateSyncTimer) return;
  // SSE 断线期间使用短轮询兜底，避免错过关键回合事件导致界面卡死。
  stateSyncTimer = setInterval(() => {
    initGameState({ silent: true, reason: 'fallback_poll' });
  }, 1500);
}

function clearSSEReconnectTimer() {
  if (!sseReconnectTimer) return;
  clearTimeout(sseReconnectTimer);
  sseReconnectTimer = null;
}

function scheduleSSEReconnect(reason) {
  if (sseReconnectTimer) return;
  if (!navigator.onLine) {
    setConnectionStatus('offline');
    return;
  }
  const delay = Math.min(8000, 1000 * (2 ** Math.min(sseReconnectAttempts, 3)));
  sseReconnectTimer = setTimeout(() => {
    sseReconnectTimer = null;
    sseReconnectAttempts += 1;
    connectSSE(reason || 'scheduled');
  }, delay);
}

function markSSEUnhealthy(reason) {
  if (!navigator.onLine) {
    setConnectionStatus('offline');
  } else {
    setConnectionStatus('reconnecting');
  }
  startStateSyncPolling();
  scheduleSSEReconnect(reason);
}

function updateRoundRoleFlags(roundData) {
  const interrogatorId = String(roundData?.interrogator_id || '');
  const subjectId = String(roundData?.subject_id || '');
  isCurrentInterrogator = interrogatorId === playerId || (myNickname && roundData?.interrogator_nickname === myNickname);
  isCurrentSubject = subjectId === playerId || (myNickname && roundData?.subject_nickname === myNickname);
}

function applyRoundIdentity(roundData) {
  setRoundDisplay(roundData.round_number, roundData.total_rounds);
  currentRoundId = String(roundData.round_id || roundData.id || '');
  const interrogatorName = String(roundData.interrogator_nickname || '未知');
  const subjectName = String(roundData.subject_nickname || '未知');
  document.getElementById('interrogator-name').textContent = interrogatorName;
  document.getElementById('interrogator-avatar').textContent = interrogatorName[0] || '?';
  document.getElementById('subject-name').textContent = subjectName;
  document.getElementById('subject-avatar').textContent = subjectName[0] || '?';
  updateRoundRoleFlags(roundData);
}

function resetRoundViewForQuestioning() {
  document.getElementById('question-text').textContent = '等待提问...';
  document.getElementById('answer-text').textContent = '等待回答...';
  document.getElementById('question-input').value = '';
  document.getElementById('answer-input').value = '';
  document.getElementById('answer-content').classList.add('hidden');
  document.getElementById('loading-area').classList.add('hidden');
  myLastVote = '';
  resetRoundFeedback();
  resetDraftSyncState();
}

function connectSSE(reason = 'init') {
  if (eventSource) {
    eventSource.close();
  }
  setConnectionStatus(navigator.onLine ? 'reconnecting' : 'offline', navigator.onLine ? '正在建立实时连接...' : '网络断开，等待恢复');

  const source = new EventSource(`/game/${roomId}/events`);
  eventSource = source;

  source.addEventListener('open', () => {
    if (eventSource !== source) return;
    const shouldResync = hasSSEConnected;
    hasSSEConnected = true;
    sseReconnectAttempts = 0;
    clearSSEReconnectTimer();
    stopStateSyncPolling();
    setConnectionStatus('connected');
    if (shouldResync) {
      initGameState({ silent: true, reason: 'sse_reopened' });
    }
  });

  // 游戏开始事件（第一回合）
  source.addEventListener('game_start', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    applyRoundIdentity(data);
    resetRoundViewForQuestioning();
    updatePhaseDisplay('questioning');
  });

  // 新回合事件（后续轮次）
  source.addEventListener('new_round', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    applyRoundIdentity(data);
    resetRoundViewForQuestioning();
    updatePhaseDisplay('questioning');
  });

  source.addEventListener('new_question', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    document.getElementById('question-text').textContent = data.question || '等待提问...';
    updatePhaseDisplay('answering');
  });

  source.addEventListener('answer_phase', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    if (data.question) {
      document.getElementById('question-text').textContent = data.question;
    }
    updatePhaseDisplay('answering');
  });

  source.addEventListener('answer_submitted', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    document.getElementById('loading-area').classList.remove('hidden');
    document.getElementById('answer-content').classList.add('hidden');

    // 回答阶段计时归零后，统一展示随机“输入中”时长，避免通过点击快慢猜测回答类型。
    const typingDelay = Math.max(0, Math.ceil(Number(data.display_delay || 0)));
    setPhaseDisplayText('输入中');
    if (typingDelay > 0) {
      startLocalCountdown(typingDelay, typingDelay);
    } else {
      stopLocalCountdown();
      countdownRemaining = 0;
      countdownTotal = 1;
      updateCountdownDisplay();
    }
  });

  source.addEventListener('new_answer', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    document.getElementById('loading-area').classList.add('hidden');
    document.getElementById('answer-content').classList.remove('hidden');
    document.getElementById('answer-text').textContent = data.answer || '（未作答）';
    // 隐藏回答类型标签（双方都无法看到是否是 AI 回答）
    document.getElementById('answer-type-label').classList.add('hidden');
    updatePhaseDisplay('voting');
  });

  source.addEventListener('voting_phase', () => {
    if (eventSource !== source) return;
    updatePhaseDisplay('voting');
    if (myLastVote && !isCurrentSubject) {
      document.getElementById('vote-area').classList.add('hidden');
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '你已投票，等待其他玩家...';
    }
  });

  source.addEventListener('countdown', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    // 使用服务器时间同步本地倒计时，避免跳来跳去
    // 根据当前阶段设置总时长
    const totalTime = phaseDurations[data.phase] || countdownTotal || phaseDurations.questioning;

    // 同步剩余时间并启动本地倒计时
    startLocalCountdown(data.remaining, totalTime);
  });

  source.addEventListener('round_result', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    updateScoreBoard(data.player_scores || []);
    renderRoundFeedback(data);
    updatePhaseDisplay('revealed');
    applyBgmForRoundResult(data);
  });

  source.addEventListener('game_over', (e) => {
    if (eventSource !== source) return;
    const data = JSON.parse(e.data || '{}');
    stopStateSyncPolling();
    window.location.href = `/game/${roomId}/result?data=` + encodeURIComponent(JSON.stringify(data));
  });

  source.onerror = () => {
    if (eventSource !== source) return;
    markSSEUnhealthy(reason || 'sse_error');
    if (source.readyState === EventSource.CLOSED) {
      scheduleSSEReconnect('sse_closed');
    }
  };
}

function forceReconnectSSE(reason = 'manual') {
  if (!navigator.onLine) {
    setConnectionStatus('offline', '当前离线，已等待自动恢复');
    return;
  }
  clearSSEReconnectTimer();
  connectSSE(reason);
}

function updatePhaseDisplay(phase) {
  currentPhase = phase;
  if (phase !== 'questioning' && questionDraftTimer) {
    clearTimeout(questionDraftTimer);
    questionDraftTimer = null;
  }
  if (phase !== 'answering' && answerDraftTimer) {
    clearTimeout(answerDraftTimer);
    answerDraftTimer = null;
  }
  
  // 阶段变化时停止本地倒计时（结果揭晓阶段不需要倒计时）
  if (phase === 'revealed') {
    stopLocalCountdown();
  }
  
  const phaseNames = {
    'questioning': '提问阶段',
    'answering': '回答阶段',
    'voting': '投票阶段',
    'revealed': '结果揭晓'
  };
  setPhaseDisplayText(phaseNames[phase] || phase);
  applyBgmForPhase(phase);

  // 显示/隐藏操作区域
  document.getElementById('question-input-area').classList.add('hidden');
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('answer-input-area').classList.add('hidden');
  document.getElementById('vote-area').classList.add('hidden');
  document.getElementById('wait-area').classList.add('hidden');

  if (phase === 'questioning') {
    if (isCurrentInterrogator) {
      document.getElementById('question-input-area').classList.remove('hidden');
    } else {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '等待提问者提问...';
    }
  } else if (phase === 'answering') {
    if (isCurrentSubject) {
      document.getElementById('answer-choice-area').classList.remove('hidden');
    } else {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '等待被测者回答...';
    }
  } else if (phase === 'voting') {
    // 被测者不能投票
    if (isCurrentSubject) {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '你是被测者，等待投票结果...';
    } else {
      document.getElementById('vote-area').classList.remove('hidden');
    }
  } else if (phase === 'revealed') {
    document.getElementById('wait-area').classList.remove('hidden');
    document.getElementById('wait-area').querySelector('p').textContent = '结果已揭晓，等待下一轮...';
  } else {
    document.getElementById('wait-area').classList.remove('hidden');
  }
}

function updateScoreBoard(playerScores) {
  const board = document.getElementById('score-board');
  board.innerHTML = '';
  // playerScores 是数组格式：[{id, nickname, score}, ...]
  for (const player of playerScores) {
    const badge = document.createElement('span');
    badge.className = 'px-3 py-1 bg-white/10 rounded-full text-white text-sm';
    badge.textContent = `${player.nickname}: ${player.score}分`;
    board.appendChild(badge);
  }
}

function formatScoreDelta(delta) {
  const value = Number(delta || 0);
  if (value > 0) return `+${value}`;
  return `${value}`;
}

function resetRoundFeedback() {
  document.getElementById('round-feedback-card').classList.add('hidden');
}

function renderRoundFeedback(result) {
  const card = document.getElementById('round-feedback-card');
  const title = document.getElementById('round-feedback-title');
  const detail = document.getElementById('round-feedback-detail');
  const score = document.getElementById('round-feedback-score');

  const scoreDelta = Number((result.scores || {})[playerId] || 0);
  const scoreText = `本轮得分变化：${formatScoreDelta(scoreDelta)} 分`;
  score.textContent = scoreText;
  score.classList.remove('text-green-300', 'text-red-300', 'text-purple-300');
  if (scoreDelta > 0) {
    score.classList.add('text-green-300');
  } else if (scoreDelta < 0) {
    score.classList.add('text-red-300');
  } else {
    score.classList.add('text-purple-300');
  }

  const subjectId = String(result.subject_id || '');
  const interrogatorId = String(result.interrogator_id || '');

  if (playerId === subjectId) {
    title.textContent = '你本轮作为被测者';
    if (!bonusScoringEnabled) {
      detail.textContent = `根据当前规则，被测者本轮不参与计分。${scoreText}`;
    } else if (scoreDelta === 50) {
      detail.textContent = `你使用 AI 回答骗过了所有陪审团，触发附加奖励。${scoreText}`;
    } else if (scoreDelta === 25) {
      detail.textContent = `你亲自回答骗过了所有陪审团，触发附加奖励。${scoreText}`;
    } else {
      detail.textContent = `附加给分机制已开启，但本轮未触发被测者奖励。${scoreText}`;
    }
    card.classList.remove('hidden');
    return;
  }

  const voteDetails = Array.isArray(result.vote_details) ? result.vote_details : [];
  const myVote = voteDetails.find((item) => item.voter_id === playerId);
  const voteValue = myVote ? myVote.vote : myLastVote;
  const voteLabel = voteValue === 'ai' ? 'AI' : voteValue === 'human' ? '真人' : '跳过';

  if (!voteValue) {
    title.textContent = '你本轮未提交投票';
    detail.textContent = scoreText;
  } else if (voteValue === 'skip') {
    title.textContent = '你本轮选择了跳过';
    detail.textContent = `你的判断：${voteLabel}。${scoreText}`;
  } else {
    const isCorrect = myVote ? Boolean(myVote.is_correct) : voteValue === result.subject_choice;
    const baseScore = isCorrect ? 50 : -30;
    const bonusScore = (playerId === interrogatorId && bonusScoringEnabled) ? scoreDelta - baseScore : 0;
    title.textContent = isCorrect ? '你本轮猜对了' : '你本轮猜错了';
    detail.textContent = `你的判断：${voteLabel}。${scoreText}`;
    if (bonusScore > 0) {
      detail.textContent += `（提问者附加奖励 +${bonusScore} 分）`;
    }
  }

  card.classList.remove('hidden');
}

async function submitQuestion() {
  if (!currentRoundId) return;
  const input = document.getElementById('question-input');
  const question = input.value.trim();
  if (!question) return;

  lastQuestionDraft = question;
  await syncDraftNow('question', question);

  // 立即隐藏提问输入区域，防止重复点击
  document.getElementById('question-input-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交问题，等待被测者回答...';

  await fetch(`/game/${roomId}/question`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `question=${encodeURIComponent(question)}&round_id=${encodeURIComponent(currentRoundId)}`
  });

  input.value = '';
}

// 显示得分规则弹窗
function showScoreRules() {
  document.getElementById('score-rules-modal').classList.remove('hidden');
}

// 隐藏得分规则弹窗
function hideScoreRules() {
  document.getElementById('score-rules-modal').classList.add('hidden');
}

// 点击弹窗背景关闭
document.addEventListener('click', function(e) {
  const modal = document.getElementById('score-rules-modal');
  if (e.target === modal) {
    hideScoreRules();
  }
});

function showHumanAnswer() {
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('answer-input-area').classList.remove('hidden');
  scheduleAnswerDraftSync();
}

async function submitAIAnswer() {
  if (!currentRoundId) return;
  // 立即隐藏选择区域，防止重复点击
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交回答，等待本阶段倒计时结束...';

  await fetch(`/game/${roomId}/answer`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `answer_type=ai&answer_content=&round_id=${encodeURIComponent(currentRoundId)}`
  });
}

async function submitHumanAnswer() {
  if (!currentRoundId) return;
  const input = document.getElementById('answer-input');
  const answer = input.value.trim();
  if (!answer) return;

  lastAnswerDraft = answer;
  await syncDraftNow('answer', answer);

  // 立即隐藏输入区域，防止重复点击
  document.getElementById('answer-input-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交回答，等待本阶段倒计时结束...';

  await fetch(`/game/${roomId}/answer`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `answer_type=human&answer_content=${encodeURIComponent(answer)}&round_id=${encodeURIComponent(currentRoundId)}`
  });

  input.value = '';
}

async function submitVote(vote) {
  if (!currentRoundId) return;
  myLastVote = vote;
  await fetch(`/game/${roomId}/vote`, {
    method: 'POST',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
    body: `vote=${vote}&round_id=${encodeURIComponent(currentRoundId)}`
  });
  
  document.getElementById('vote-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已投票，等待其他玩家...';
}

// 当前玩家角色
let isCurrentInterrogator = false;
let isCurrentSubject = false;
let myNickname = '';

function redirectByRoomPhase(phase) {
  const normalized = String(phase || '').trim().toLowerCase();
  if (normalized === 'setup') {
    window.location.href = `/game/${roomId}/setup`;
    return true;
  }
  if (normalized === 'waiting') {
    window.location.href = `/game/${roomId}`;
    return true;
  }
  if (normalized === 'finished') {
    window.location.href = `/game/${roomId}/result`;
    return true;
  }
  return false;
}

function applyRoundSnapshot(round) {
  if (!round) return;
  applyRoundIdentity(round);

  const questionText = String(round.question || '').trim();
  const answerText = String(round.answer || '').trim();
  const isAnswerVisible = Boolean(round.is_answer_visible);
  const isAnswerSubmitted = Boolean(round.is_answer_submitted);
  const questionInput = document.getElementById('question-input');
  const answerInput = document.getElementById('answer-input');
  const loadingArea = document.getElementById('loading-area');
  const answerContent = document.getElementById('answer-content');

  document.getElementById('question-text').textContent = questionText || '等待提问...';

  if (questionInput) {
    const remoteQuestionDraft = String(round.my_question_draft || '');
    if (isCurrentInterrogator && round.status === 'questioning' && !questionText && remoteQuestionDraft && !questionInput.value.trim()) {
      questionInput.value = remoteQuestionDraft;
    }
    if (remoteQuestionDraft) {
      lastQuestionDraft = remoteQuestionDraft;
    }
  }

  if (answerInput) {
    const remoteAnswerDraft = String(round.my_answer_draft || '');
    if (isCurrentSubject && round.status === 'answering' && !isAnswerSubmitted && remoteAnswerDraft && !answerInput.value.trim()) {
      answerInput.value = remoteAnswerDraft;
    }
    if (remoteAnswerDraft) {
      lastAnswerDraft = remoteAnswerDraft;
    }
  }

  if (isAnswerVisible && answerText) {
    loadingArea.classList.add('hidden');
    answerContent.classList.remove('hidden');
    document.getElementById('answer-text').textContent = answerText;
    document.getElementById('answer-type-label').classList.add('hidden');
  } else {
    answerContent.classList.add('hidden');
    document.getElementById('answer-text').textContent = '等待回答...';
    if (round.status === 'answering' && (isAnswerSubmitted || !isCurrentSubject)) {
      loadingArea.classList.remove('hidden');
    } else {
      loadingArea.classList.add('hidden');
    }
  }

  updatePhaseDisplay(round.status);
  myLastVote = String(round.my_vote || '').trim();

  // 断线重连后若已提交回答/投票，强制回到等待态，避免继续展示可操作按钮。
  if (round.status === 'answering' && isCurrentSubject && isAnswerSubmitted) {
    document.getElementById('answer-choice-area').classList.add('hidden');
    document.getElementById('answer-input-area').classList.add('hidden');
    document.getElementById('wait-area').classList.remove('hidden');
    document.getElementById('wait-area').querySelector('p').textContent = '你已提交回答，等待本阶段结束...';
  }
  if (round.status === 'voting' && !isCurrentSubject && myLastVote) {
    document.getElementById('vote-area').classList.add('hidden');
    document.getElementById('wait-area').classList.remove('hidden');
    document.getElementById('wait-area').querySelector('p').textContent = '你已投票，等待其他玩家...';
  }
}

// 页面加载和重连后都调用该方法，确保丢失 SSE 事件时可以从服务端快照恢复 UI。
async function initGameState(options = {}) {
  const silent = Boolean(options?.silent);
  if (isSyncingGameState) return;
  isSyncingGameState = true;

  try {
    const roomRes = await fetch(`/game/api/${roomId}/state`, { cache: 'no-store' });
    const roomData = await roomRes.json();

    if (!roomData.success || !roomData.room) {
      if (!silent) {
        console.warn('房间状态恢复失败：', roomData.error || '未知错误');
      }
      return;
    }

    setRoundDisplay(roomData.room.current_round, roomData.room.total_rounds);
    if (redirectByRoomPhase(roomData.room.phase)) return;

    if (Array.isArray(roomData.players)) {
      const me = roomData.players.find((player) => player.id === playerId);
      if (me) {
        myNickname = String(me.nickname || '');
      }
      const playerScores = roomData.players.map((player) => ({
        id: player.id,
        nickname: player.nickname,
        score: player.score || 0,
      }));
      updateScoreBoard(playerScores);
    }

    const roundRes = await fetch(`/game/api/${roomId}/round`, { cache: 'no-store' });
    const roundData = await roundRes.json();
    if (roundData.success && roundData.round) {
      applyRoundSnapshot(roundData.round);
      return;
    }

    if (redirectByRoomPhase(roundData.phase)) return;
    if (!silent) {
      console.warn('回合状态恢复失败：', roundData.error || '未知错误');
    }
  } catch (e) {
    if (!silent) {
      console.error('Failed to init game state:', e);
    }
  } finally {
    isSyncingGameState = false;
  }
}

// 回答区仅允许手动输入，禁止粘贴/拖拽注入文本（提问区不受影响）。
function lockAnswerInputPaste() {
  const answerInput = document.getElementById('answer-input');
  if (!answerInput) return;

  const blockPasteLikeInput = (event) => {
    const inputType = String(event.inputType || '');
    if (inputType === 'insertFromPaste' || inputType === 'insertFromDrop') {
      event.preventDefault();
    }
  };

  answerInput.addEventListener('beforeinput', blockPasteLikeInput);
  answerInput.addEventListener('paste', (event) => event.preventDefault());
  answerInput.addEventListener('drop', (event) => event.preventDefault());
  answerInput.addEventListener('keydown', (event) => {
    const key = String(event.key || '').toLowerCase();
    if ((event.ctrlKey || event.metaKey) && key === 'v') {
      event.preventDefault();
      return;
    }
    if (event.shiftKey && key === 'insert') {
      event.preventDefault();
    }
  });
}

function flushDraftOnBeforeUnload() {
  if (!currentRoundId || typeof navigator.sendBeacon !== 'function') return;
  const params = new URLSearchParams();
  if (isCurrentInterrogator && currentPhase === 'questioning') {
    const questionDraft = document.getElementById('question-input')?.value || '';
    if (questionDraft !== lastQuestionDraft) {
      params.set('round_id', currentRoundId);
      params.set('draft_type', 'question');
      params.set('content', questionDraft);
      navigator.sendBeacon(`/game/${roomId}/draft`, params);
      return;
    }
  }
  if (isCurrentSubject && currentPhase === 'answering') {
    const answerDraft = document.getElementById('answer-input')?.value || '';
    if (answerDraft !== lastAnswerDraft) {
      params.set('round_id', currentRoundId);
      params.set('draft_type', 'answer');
      params.set('content', answerDraft);
      navigator.sendBeacon(`/game/${roomId}/draft`, params);
    }
  }
}

function handleNetworkOnline() {
  setConnectionStatus('reconnecting', '网络已恢复，正在重连...');
  initGameState({ silent: true, reason: 'network_online' });
  forceReconnectSSE('network_online');
}

function handleNetworkOffline() {
  markSSEUnhealthy('network_offline');
}

function handlePageVisible() {
  if (document.hidden) return;
  initGameState({ silent: true, reason: 'page_visible' });
  if (!eventSource || eventSource.readyState !== EventSource.OPEN) {
    forceReconnectSSE('page_visible');
  }
}

// 页面加载时先获取状态，再连接 SSE
lockAnswerInputPaste();
document.getElementById('question-input').addEventListener('input', scheduleQuestionDraftSync);
document.getElementById('answer-input').addEventListener('input', scheduleAnswerDraftSync);
window.addEventListener('online', handleNetworkOnline);
window.addEventListener('offline', handleNetworkOffline);
document.addEventListener('visibilitychange', handlePageVisible);

setConnectionStatus(navigator.onLine ? 'reconnecting' : 'offline', navigator.onLine ? '初始化连接中...' : '网络断开，等待恢复');
initGameState({ reason: 'initial_load' }).then(() => {
  connectSSE('initial_load');
});

window.addEventListener('beforeunload', () => {
  flushDraftOnBeforeUnload();
  stopLocalCountdown();
  stopStateSyncPolling();
  clearSSEReconnectTimer();
  window.removeEventListener('online', handleNetworkOnline);
  window.removeEventListener('offline', handleNetworkOffline);
  document.removeEventListener('visibilitychange', handlePageVisible);
  if (eventSource) {
    eventSource.close();
  }
});
</script>
{% endblock %}
