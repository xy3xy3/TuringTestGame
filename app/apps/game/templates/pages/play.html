{% extends "base.html" %}

{% block title %}游戏进行中 - 图灵测试{% endblock %}

{% block content %}
<div class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 px-4 pb-4 pt-20 md:p-4">
  <!-- 移动端固定倒计时条：滚动时始终可见，避免错过提问/回答/投票时限。 -->
  <div class="fixed inset-x-0 z-50 px-3 md:hidden pointer-events-none" style="top: calc(env(safe-area-inset-top, 0px) + 8px);">
    <div class="mx-auto max-w-md rounded-xl border border-white/20 bg-slate-900/80 px-3 py-2 backdrop-blur-md shadow-lg">
      <div class="flex items-center justify-between text-xs text-purple-100">
        <span class="font-medium">第 <span id="mobile-round-number">{{ current_round }}</span>/<span id="mobile-total-rounds">{{ room.total_rounds }}</span> 回合 · <span id="mobile-phase-display">等待中...</span></span>
        <span class="text-base font-bold text-purple-200"><span id="mobile-countdown">--</span>s</span>
      </div>
      <div class="mt-2 h-1.5 bg-white/20 rounded-full overflow-hidden">
        <div id="mobile-progress-bar" class="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-1000" style="width: 0%"></div>
      </div>
    </div>
  </div>
  <div class="max-w-4xl mx-auto">
    <!-- 顶部信息栏 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4 mb-4">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-xl font-bold text-white">第 <span id="round-number">{{ current_round }}</span>/<span id="total-rounds">{{ room.total_rounds }}</span> 回合</h1>
          <p class="text-purple-200 text-sm">房间号：{{ room.room_id }}</p>
        </div>
        <div class="text-right">
          <div id="phase-display" class="text-lg font-semibold text-white">等待中...</div>
          <div id="countdown" class="text-3xl font-bold text-purple-400">--</div>
          <div class="mt-2 flex items-center justify-end gap-2 text-xs">
            <span id="connection-indicator" class="inline-flex items-center gap-1 rounded-full border border-white/20 bg-white/10 px-2 py-1 text-purple-100">
              <span id="connection-dot" class="h-2 w-2 rounded-full bg-green-400"></span>
              <span id="connection-text">实时连接正常</span>
            </span>
            <button
              id="reconnect-btn"
              type="button"
              class="rounded-full border border-white/20 bg-white/10 px-2 py-1 text-purple-100 transition hover:bg-white/20"
              onclick="forceReconnectSSE('manual')"
            >
              立即重连
            </button>
          </div>
        </div>
      </div>
      
      <!-- 进度条 -->
      <div class="mt-3 h-1.5 bg-white/20 rounded-full overflow-hidden">
        <div id="progress-bar" class="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-1000" style="width: 0%"></div>
      </div>
    </div>

    <!-- 玩家信息栏 -->
    <div class="grid grid-cols-2 gap-4 mb-4">
      <!-- 提问者 -->
      <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4">
        <p class="text-purple-200 text-sm mb-1">提问者</p>
        <div class="flex items-center gap-2">
          <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white text-sm font-bold" id="interrogator-avatar">
            ?
          </div>
          <span class="text-white font-medium" id="interrogator-name">等待中...</span>
        </div>
      </div>
      
      <!-- 被测者 -->
      <div class="bg-white/10 backdrop-blur-md rounded-2xl p-4">
        <p class="text-purple-200 text-sm mb-1">被测者</p>
        <div class="flex items-center gap-2">
          <div class="w-8 h-8 rounded-full bg-pink-500 flex items-center justify-center text-white text-sm font-bold" id="subject-avatar">
            ?
          </div>
          <span class="text-white font-medium" id="subject-name">等待中...</span>
        </div>
      </div>
    </div>

    <!-- 问答区域 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-6 mb-4 min-h-[300px]">
      <!-- 问题显示 -->
      <div id="question-area" class="mb-6">
        <p class="text-purple-200 text-sm mb-2">问题：</p>
        <div class="bg-blue-500/20 rounded-xl p-4">
          <p class="text-white text-lg" id="question-text">等待提问...</p>
        </div>
      </div>

      <!-- 回答显示 -->
      <div id="answer-area">
        <p class="text-purple-200 text-sm mb-2">回答：</p>
        <div id="answer-content" class="bg-pink-500/20 rounded-xl p-4 hidden">
          <p class="text-white text-lg" id="answer-text">等待回答...</p>
          <p class="text-purple-300 text-sm mt-2" id="answer-type-label"></p>
        </div>
        
        <!-- 加载动画 -->
        <div id="loading-area" class="text-center py-8">
          <div class="inline-flex items-center gap-2 text-purple-300">
            <i class="fa-solid fa-circle-notch fa-spin text-2xl"></i>
            <span>对方正在输入...</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 操作区域 -->
    <div class="bg-white/10 backdrop-blur-md rounded-2xl p-6">
      <!-- 提问者输入 -->
      <div id="question-input-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请输入你的问题：</p>
        <div class="flex gap-2">
          <input type="text" id="question-input" class="input flex-1" placeholder="输入问题..." 
            onkeypress="if(event.key==='Enter') submitQuestion()" />
          <button class="btn-primary px-6" onclick="submitQuestion()">提问</button>
        </div>
      </div>

      <!-- 被测者选择 -->
      <div id="answer-choice-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请选择回答方式：</p>
        <div class="flex gap-4">
          <button class="flex-1 bg-gradient-to-r from-green-500 to-emerald-500 text-white font-bold py-4 px-6 rounded-xl hover:from-green-600 hover:to-emerald-600 transition-all" onclick="showHumanAnswer()">
            <i class="fa-solid fa-user mr-2"></i>亲自回答
          </button>
          <button class="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 px-6 rounded-xl hover:from-purple-600 hover:to-pink-600 transition-all" onclick="submitAIAnswer()">
            <i class="fa-solid fa-robot mr-2"></i>AI 代答
          </button>
        </div>
      </div>

      <!-- 被测者手动输入 -->
      <div id="answer-input-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">请输入你的回答：</p>
        <div class="flex gap-2">
          <textarea id="answer-input" class="input flex-1 h-24" placeholder="输入回答..."></textarea>
          <button class="btn-primary px-6" onclick="submitHumanAnswer()">提交</button>
        </div>
      </div>

      <!-- 投票区域 -->
      <div id="vote-area" class="hidden">
        <p class="text-purple-200 text-sm mb-2">判断这个回答是：</p>
        <div class="flex gap-4">
          <button class="flex-1 bg-blue-500/20 hover:bg-blue-500/40 text-blue-400 font-bold py-3 px-4 rounded-xl border border-blue-500/30 transition-all" onclick="submitVote('human')">
            <i class="fa-solid fa-user mr-2"></i>真人
          </button>
          <button class="flex-1 bg-red-500/20 hover:bg-red-500/40 text-red-400 font-bold py-3 px-4 rounded-xl border border-red-500/30 transition-all" onclick="submitVote('ai')">
            <i class="fa-solid fa-robot mr-2"></i>AI
          </button>
          <button class="flex-1 bg-gray-500/20 hover:bg-gray-500/40 text-gray-400 font-bold py-3 px-4 rounded-xl border border-gray-500/30 transition-all" onclick="submitVote('skip')">
            <i class="fa-solid fa-forward mr-2"></i>跳过
          </button>
        </div>
      </div>

      <!-- 等待区域 -->
      <div id="wait-area" class="text-center py-8">
        <p class="text-purple-300">请等待其他玩家操作...</p>
      </div>
    </div>

    <!-- 玩家得分 -->
    <div class="mt-4 bg-white/10 backdrop-blur-md rounded-2xl p-4">
      <div class="flex items-center justify-between mb-2">
        <p class="text-purple-200 text-sm">玩家得分：</p>
        <button onclick="showScoreRules()" class="text-purple-300 hover:text-white text-sm underline">
          <i class="fa-solid fa-circle-question mr-1"></i>得分规则
        </button>
      </div>
      <div class="flex flex-wrap gap-2" id="score-board">
        <!-- 玩家得分由 SSE 更新 -->
      </div>

      <div id="round-feedback-card" class="mt-3 hidden rounded-xl border border-white/10 bg-white/5 px-4 py-3">
        <p id="round-feedback-title" class="text-sm font-semibold text-white">本轮反馈</p>
        <p id="round-feedback-detail" class="mt-1 text-xs text-purple-200">等待本轮结算...</p>
        <p id="round-feedback-score" class="mt-2 text-sm font-bold text-purple-300">本轮得分变化：0 分</p>
      </div>
    </div>
  </div>
</div>

<!-- 得分规则弹窗 -->
<div id="score-rules-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
  <div class="bg-slate-800 rounded-2xl max-w-md w-full p-6 border border-white/10">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-xl font-bold text-white">得分规则</h3>
      <button onclick="hideScoreRules()" class="text-gray-400 hover:text-white">
        <i class="fa-solid fa-xmark text-xl"></i>
      </button>
    </div>
    <div class="space-y-4 text-gray-300 text-sm max-h-[60vh] overflow-y-auto">
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-gavel text-blue-400 mr-2"></i>投票玩家（提问者 + 陪审团）
        </h4>
        <ul class="space-y-1 ml-6 list-disc">
          <li>猜对回答类型：<span class="text-green-400 font-bold">+50分</span></li>
          <li>猜错回答类型：<span class="text-red-400 font-bold">-30分</span></li>
          <li>选择跳过：<span class="text-gray-400">0分</span></li>
        </ul>
      </div>
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-bolt text-yellow-300 mr-2"></i>附加给分机制
        </h4>
        {% if room.config.bonus_scoring_enabled %}
        <ul class="space-y-1 ml-6 list-disc">
          <li>提问者若让所有陪审团答对：<span class="text-green-400 font-bold">额外 +50分</span></li>
          <li>被测者使用 AI 回答且骗过所有陪审团：<span class="text-green-400 font-bold">额外 +50分</span></li>
          <li>被测者亲自回答且骗过所有陪审团：<span class="text-green-400 font-bold">额外 +25分</span></li>
        </ul>
        {% else %}
        <p class="text-xs text-gray-400">本局未开启附加给分机制，仅按投票结果计分。</p>
        {% endif %}
      </div>
      <div>
        <h4 class="text-white font-semibold mb-2 flex items-center">
          <i class="fa-solid fa-user-shield text-pink-400 mr-2"></i>被测者
        </h4>
        {% if room.config.bonus_scoring_enabled %}
        <ul class="space-y-1 ml-6 list-disc">
          <li>本轮不参与投票，默认得分为 <span class="text-gray-300 font-bold">0 分</span></li>
          <li>满足附加机制条件时可获得额外加分</li>
        </ul>
        {% else %}
        <ul class="space-y-1 ml-6 list-disc">
          <li>本轮不参与投票与计分：<span class="text-gray-300 font-bold">固定 0 分</span></li>
          <li>仍正常参与回答流程，并等待其他玩家投票完成</li>
        </ul>
        {% endif %}
      </div>
      <div class="bg-white/5 rounded-lg p-3 text-xs text-gray-400">
        <p><i class="fa-solid fa-lightbulb text-yellow-400 mr-1"></i>小贴士：跳过不加减分，附加机制仅在房主开启后生效。</p>
      </div>
    </div>
  </div>
</div>

<script>
const roomId = '{{ room.id }}';
const playerId = '{{ player_id }}';
const bonusScoringEnabled = {{ "true" if room.config.bonus_scoring_enabled else "false" }};
let currentRound = {{ current_round }};
let totalRounds = {{ room.total_rounds }};
let currentPhase = 'waiting';
let currentRoundId = '';
let myLastVote = '';
const phaseDurations = {
  setup: {{ room.config.setup_duration }},
  questioning: {{ room.config.question_duration }},
  answering: {{ room.config.answer_duration }},
  voting: {{ room.config.vote_duration }},
};

// 倒计时相关
let countdownRemaining = 0;
let countdownTotal = phaseDurations.questioning;  // 当前阶段总时长
let countdownInterval = null;

// 草稿同步相关
let questionDraftTimer = null;
let answerDraftTimer = null;
let lastQuestionDraft = '';
let lastAnswerDraft = '';

// SSE 连接
let sseClient = null;
let hasSSEConnected = false;
let lastSSEActivityAt = Date.now();
let sseWatchdogTimer = null;
let stateSyncTimer = null;
let isSyncingGameState = false;
const pendingDraftQueue = new Map();
let isFlushingDraftQueue = false;

function mapPhaseToBgmStage(phase) {
  const phaseKey = String(phase || '').trim().toLowerCase();
  if (phaseKey === 'questioning') return 'playing_questioning';
  if (phaseKey === 'answering') return 'playing_answering';
  if (phaseKey === 'voting') return 'playing_voting';
  return '';
}

function applyBgmForPhase(phase) {
  const stage = mapPhaseToBgmStage(phase);
  if (!stage || typeof window.setGameBgmStage !== 'function') return;
  window.setGameBgmStage(stage);
}

function applyBgmForRoundResult(result) {
  if (typeof window.setGameBgmStage !== 'function') return;
  const scores = result?.scores || {};
  const delta = Number(scores[playerId] || 0);
  if (delta > 0) {
    window.setGameBgmStage('playing_scored');
    return;
  }
  if (delta < 0) {
    window.setGameBgmStage('playing_penalty');
    return;
  }
  window.setGameBgmStage('playing_skipped');
}

// 启动本地倒计时
function startLocalCountdown(remaining, total) {
  // 如果本地倒计时已经在运行，且时间差小于2秒，不需要重新同步
  // 这样可以避免 SSE 每秒推送导致的"跳来跳去"
  if (countdownInterval && Math.abs(countdownRemaining - remaining) < 2) {
    return;
  }
  
  countdownRemaining = remaining;
  countdownTotal = total || remaining;
  
  // 清除之前的定时器
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
  
  // 立即更新显示
  updateCountdownDisplay();
  
  // 每秒递减
  countdownInterval = setInterval(() => {
    countdownRemaining = Math.max(0, countdownRemaining - 1);
    updateCountdownDisplay();
    
    if (countdownRemaining <= 0) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }
  }, 1000);
}

// 更新倒计时显示
function updateCountdownDisplay() {
  const desktopCountdown = document.getElementById('countdown');
  const mobileCountdown = document.getElementById('mobile-countdown');
  if (desktopCountdown) {
    desktopCountdown.textContent = countdownRemaining;
  }
  if (mobileCountdown) {
    mobileCountdown.textContent = countdownRemaining;
  }
  const percent = countdownTotal > 0 ? (countdownRemaining / countdownTotal) * 100 : 0;
  const desktopProgressBar = document.getElementById('progress-bar');
  const mobileProgressBar = document.getElementById('mobile-progress-bar');
  if (desktopProgressBar) {
    desktopProgressBar.style.width = `${percent}%`;
  }
  if (mobileProgressBar) {
    mobileProgressBar.style.width = `${percent}%`;
  }
}

// 停止本地倒计时
function stopLocalCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
}

// 更新顶部回合显示（第 x / y 回合）
function setRoundDisplay(roundNumber, totalRoundNumber) {
  if (Number.isFinite(Number(roundNumber))) {
    currentRound = Number(roundNumber);
    document.getElementById('round-number').textContent = String(currentRound);
    const mobileRoundNumber = document.getElementById('mobile-round-number');
    if (mobileRoundNumber) {
      mobileRoundNumber.textContent = String(currentRound);
    }
  }
  if (Number.isFinite(Number(totalRoundNumber))) {
    totalRounds = Number(totalRoundNumber);
    document.getElementById('total-rounds').textContent = String(totalRounds);
    const mobileTotalRounds = document.getElementById('mobile-total-rounds');
    if (mobileTotalRounds) {
      mobileTotalRounds.textContent = String(totalRounds);
    }
  }
}

function setPhaseDisplayText(text) {
  const normalizedText = String(text || '等待中...');
  const desktopPhaseDisplay = document.getElementById('phase-display');
  const mobilePhaseDisplay = document.getElementById('mobile-phase-display');
  if (desktopPhaseDisplay) {
    desktopPhaseDisplay.textContent = normalizedText;
  }
  if (mobilePhaseDisplay) {
    mobilePhaseDisplay.textContent = normalizedText;
  }
}

function resetDraftSyncState() {
  if (questionDraftTimer) {
    clearTimeout(questionDraftTimer);
    questionDraftTimer = null;
  }
  if (answerDraftTimer) {
    clearTimeout(answerDraftTimer);
    answerDraftTimer = null;
  }
  lastQuestionDraft = '';
  lastAnswerDraft = '';
  pendingDraftQueue.clear();
}

async function syncDraftNow(draftType, content) {
  if (!currentRoundId) return;
  const normalizedType = String(draftType || '').trim().toLowerCase();
  if (!normalizedType) return;
  const queueKey = `${currentRoundId}:${normalizedType}`;
  const normalizedContent = String(content || '');
  const requestFn = typeof window.requestWithRetry === 'function' ? window.requestWithRetry : fetch;

  try {
    await requestFn(
      `/game/${roomId}/draft`,
      {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: `round_id=${encodeURIComponent(currentRoundId)}&draft_type=${encodeURIComponent(normalizedType)}&content=${encodeURIComponent(normalizedContent)}`,
      },
      {
        timeoutMs: 3500,
        retries: 1,
      },
    );
    pendingDraftQueue.delete(queueKey);
  } catch (error) {
    // 网络异常时暂存草稿，待恢复后再冲刷，避免玩家输入丢失。
    pendingDraftQueue.set(queueKey, {
      roundId: currentRoundId,
      draftType: normalizedType,
      content: normalizedContent,
    });
    console.warn('草稿同步失败，已加入待重试队列：', error);
  }
}

// 连接恢复后冲刷待发送草稿，减少网络抖动导致的输入丢失。
async function flushPendingDraftQueue() {
  if (isFlushingDraftQueue || !pendingDraftQueue.size) return;
  isFlushingDraftQueue = true;

  try {
    const entries = Array.from(pendingDraftQueue.entries());
    for (const [queueKey, payload] of entries) {
      if (!payload || payload.roundId !== currentRoundId) {
        pendingDraftQueue.delete(queueKey);
        continue;
      }
      await syncDraftNow(payload.draftType, payload.content);
    }
  } finally {
    isFlushingDraftQueue = false;
  }
}

function scheduleQuestionDraftSync() {
  if (!isCurrentInterrogator || currentPhase !== 'questioning' || !currentRoundId) return;
  const questionInput = document.getElementById('question-input');
  if (!questionInput) return;

  if (questionDraftTimer) {
    clearTimeout(questionDraftTimer);
  }
  questionDraftTimer = setTimeout(async () => {
    questionDraftTimer = null;
    const draft = questionInput.value || '';
    if (draft === lastQuestionDraft) return;
    lastQuestionDraft = draft;
    await syncDraftNow('question', draft);
  }, 250);
}

function scheduleAnswerDraftSync() {
  if (!isCurrentSubject || currentPhase !== 'answering' || !currentRoundId) return;
  const answerInput = document.getElementById('answer-input');
  if (!answerInput) return;

  if (answerDraftTimer) {
    clearTimeout(answerDraftTimer);
  }
  answerDraftTimer = setTimeout(async () => {
    answerDraftTimer = null;
    const draft = answerInput.value || '';
    if (draft === lastAnswerDraft) return;
    lastAnswerDraft = draft;
    await syncDraftNow('answer', draft);
  }, 250);
}

function setConnectionStatus(status, customText = '') {
  const dot = document.getElementById('connection-dot');
  const text = document.getElementById('connection-text');
  if (!dot || !text) return;

  dot.classList.remove('bg-green-400', 'bg-yellow-400', 'bg-red-400');
  if (status === 'connected') {
    dot.classList.add('bg-green-400');
    text.textContent = customText || '实时连接正常';
    return;
  }
  if (status === 'offline') {
    dot.classList.add('bg-red-400');
    text.textContent = customText || '网络断开，等待恢复';
    return;
  }
  dot.classList.add('bg-yellow-400');
  text.textContent = customText || '连接波动，重连中...';
}

function stopStateSyncPolling() {
  if (!stateSyncTimer) return;
  clearInterval(stateSyncTimer);
  stateSyncTimer = null;
}

function startStateSyncPolling() {
  if (stateSyncTimer) return;
  // SSE 断线期间使用短轮询兜底，避免错过关键回合事件导致界面卡死。
  stateSyncTimer = setInterval(() => {
    initGameState({ silent: true, reason: 'fallback_poll' });
  }, 1500);
}

// 记录最近一次 SSE 活跃时间，供静默看门狗判断连接健康度。
function markSSEActivity() {
  lastSSEActivityAt = Date.now();
}

// 启动 SSE 静默看门狗，长时间无事件时主动触发重连。
function startSSEWatchdog() {
  if (sseWatchdogTimer) return;
  sseWatchdogTimer = setInterval(() => {
    if (!sseClient || !sseClient.isOpen()) return;
    const idleForMs = Date.now() - lastSSEActivityAt;
    if (idleForMs <= 30000) return;

    // 超过 30 秒未收到事件（含 ping）判定为链路假活跃，强制触发重连。
    setConnectionStatus('reconnecting', '连接静默超时，正在重连...');
    startStateSyncPolling();
    markSSEActivity();
    sseClient.forceReconnect('watchdog_timeout');
  }, 5000);
}

// 页面销毁时关闭看门狗，避免多实例定时器泄漏。
function stopSSEWatchdog() {
  if (!sseWatchdogTimer) return;
  clearInterval(sseWatchdogTimer);
  sseWatchdogTimer = null;
}

function updateRoundRoleFlags(roundData) {
  const interrogatorId = String(roundData?.interrogator_id || '');
  const subjectId = String(roundData?.subject_id || '');
  isCurrentInterrogator = interrogatorId === playerId || (myNickname && roundData?.interrogator_nickname === myNickname);
  isCurrentSubject = subjectId === playerId || (myNickname && roundData?.subject_nickname === myNickname);
}

function applyRoundIdentity(roundData) {
  setRoundDisplay(roundData.round_number, roundData.total_rounds);
  currentRoundId = String(roundData.round_id || roundData.id || '');
  const interrogatorName = String(roundData.interrogator_nickname || '未知');
  const subjectName = String(roundData.subject_nickname || '未知');
  document.getElementById('interrogator-name').textContent = interrogatorName;
  document.getElementById('interrogator-avatar').textContent = interrogatorName[0] || '?';
  document.getElementById('subject-name').textContent = subjectName;
  document.getElementById('subject-avatar').textContent = subjectName[0] || '?';
  updateRoundRoleFlags(roundData);
}

function resetRoundViewForQuestioning() {
  document.getElementById('question-text').textContent = '等待提问...';
  document.getElementById('answer-text').textContent = '等待回答...';
  document.getElementById('question-input').value = '';
  document.getElementById('answer-input').value = '';
  document.getElementById('answer-content').classList.add('hidden');
  document.getElementById('loading-area').classList.add('hidden');
  myLastVote = '';
  resetRoundFeedback();
  resetDraftSyncState();
}

function connectSSE(reason = 'init') {
  if (!sseClient) {
    sseClient = window.createResilientSSE({
      url: `/game/${roomId}/events`,
      onStatusChange: (status) => {
        if (status === 'connected') {
          const shouldResync = hasSSEConnected;
          hasSSEConnected = true;
          stopStateSyncPolling();
          setConnectionStatus('connected');
          markSSEActivity();
          flushPendingDraftQueue();
          if (shouldResync) {
            initGameState({ silent: true, reason: 'sse_reopened' });
          }
          return;
        }

        startStateSyncPolling();
        if (status === 'offline') {
          setConnectionStatus('offline');
          return;
        }
        setConnectionStatus('reconnecting');
      },
      events: {
        ping: () => {
          markSSEActivity();
        },
        game_start: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          applyRoundIdentity(data);
          resetRoundViewForQuestioning();
          updatePhaseDisplay('questioning');
        },
        new_round: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          applyRoundIdentity(data);
          resetRoundViewForQuestioning();
          updatePhaseDisplay('questioning');
        },
        new_question: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          document.getElementById('question-text').textContent = data.question || '等待提问...';
          updatePhaseDisplay('answering');
        },
        answer_phase: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          if (data.question) {
            document.getElementById('question-text').textContent = data.question;
          }
          updatePhaseDisplay('answering');
        },
        answer_submitted: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          document.getElementById('loading-area').classList.remove('hidden');
          document.getElementById('answer-content').classList.add('hidden');

          // 回答阶段计时归零后，统一展示随机“输入中”时长，避免通过点击快慢猜测回答类型。
          const typingDelay = Math.max(0, Math.ceil(Number(data.display_delay || 0)));
          setPhaseDisplayText('输入中');
          if (typingDelay > 0) {
            startLocalCountdown(typingDelay, typingDelay);
          } else {
            stopLocalCountdown();
            countdownRemaining = 0;
            countdownTotal = 1;
            updateCountdownDisplay();
          }
        },
        new_answer: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          document.getElementById('loading-area').classList.add('hidden');
          document.getElementById('answer-content').classList.remove('hidden');
          document.getElementById('answer-text').textContent = data.answer || '（未作答）';
          document.getElementById('answer-type-label').classList.add('hidden');
          updatePhaseDisplay('voting');
        },
        voting_phase: () => {
          markSSEActivity();
          updatePhaseDisplay('voting');
          if (myLastVote && !isCurrentSubject) {
            document.getElementById('vote-area').classList.add('hidden');
            document.getElementById('wait-area').classList.remove('hidden');
            document.getElementById('wait-area').querySelector('p').textContent = '你已投票，等待其他玩家...';
          }
        },
        countdown: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          const totalTime = phaseDurations[data.phase] || countdownTotal || phaseDurations.questioning;
          startLocalCountdown(data.remaining, totalTime);
        },
        round_result: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          updateScoreBoard(data.player_scores || []);
          renderRoundFeedback(data);
          updatePhaseDisplay('revealed');
          applyBgmForRoundResult(data);
        },
        game_over: (e) => {
          markSSEActivity();
          const data = JSON.parse(e.data || '{}');
          stopStateSyncPolling();
          window.location.href = `/game/${roomId}/result?data=` + encodeURIComponent(JSON.stringify(data));
        },
      },
    });
    startSSEWatchdog();
  }

  if (!navigator.onLine) {
    setConnectionStatus('offline', '网络断开，等待恢复');
    startStateSyncPolling();
    return;
  }
  if (hasSSEConnected) {
    sseClient.forceReconnect(reason);
    return;
  }
  sseClient.connect(reason);
}

function forceReconnectSSE(reason = 'manual') {
  if (!sseClient) {
    connectSSE(reason);
    return;
  }
  if (!navigator.onLine) {
    setConnectionStatus('offline', '当前离线，已等待自动恢复');
    return;
  }
  sseClient.forceReconnect(reason);
}

function updatePhaseDisplay(phase) {
  currentPhase = phase;
  if (phase !== 'questioning' && questionDraftTimer) {
    clearTimeout(questionDraftTimer);
    questionDraftTimer = null;
  }
  if (phase !== 'answering' && answerDraftTimer) {
    clearTimeout(answerDraftTimer);
    answerDraftTimer = null;
  }
  
  // 阶段变化时停止本地倒计时（结果揭晓阶段不需要倒计时）
  if (phase === 'revealed') {
    stopLocalCountdown();
  }
  
  const phaseNames = {
    'questioning': '提问阶段',
    'answering': '回答阶段',
    'voting': '投票阶段',
    'revealed': '结果揭晓'
  };
  setPhaseDisplayText(phaseNames[phase] || phase);
  applyBgmForPhase(phase);

  // 显示/隐藏操作区域
  document.getElementById('question-input-area').classList.add('hidden');
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('answer-input-area').classList.add('hidden');
  document.getElementById('vote-area').classList.add('hidden');
  document.getElementById('wait-area').classList.add('hidden');

  if (phase === 'questioning') {
    if (isCurrentInterrogator) {
      document.getElementById('question-input-area').classList.remove('hidden');
    } else {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '等待提问者提问...';
    }
  } else if (phase === 'answering') {
    if (isCurrentSubject) {
      document.getElementById('answer-choice-area').classList.remove('hidden');
    } else {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '等待被测者回答...';
    }
  } else if (phase === 'voting') {
    // 被测者不能投票
    if (isCurrentSubject) {
      document.getElementById('wait-area').classList.remove('hidden');
      document.getElementById('wait-area').querySelector('p').textContent = '你是被测者，等待投票结果...';
    } else {
      document.getElementById('vote-area').classList.remove('hidden');
    }
  } else if (phase === 'revealed') {
    document.getElementById('wait-area').classList.remove('hidden');
    document.getElementById('wait-area').querySelector('p').textContent = '结果已揭晓，等待下一轮...';
  } else {
    document.getElementById('wait-area').classList.remove('hidden');
  }
}

function updateScoreBoard(playerScores) {
  const board = document.getElementById('score-board');
  board.innerHTML = '';
  // playerScores 是数组格式：[{id, nickname, score}, ...]
  for (const player of playerScores) {
    const badge = document.createElement('span');
    badge.className = 'px-3 py-1 bg-white/10 rounded-full text-white text-sm';
    badge.textContent = `${player.nickname}: ${player.score}分`;
    board.appendChild(badge);
  }
}

function formatScoreDelta(delta) {
  const value = Number(delta || 0);
  if (value > 0) return `+${value}`;
  return `${value}`;
}

function resetRoundFeedback() {
  document.getElementById('round-feedback-card').classList.add('hidden');
}

function renderRoundFeedback(result) {
  const card = document.getElementById('round-feedback-card');
  const title = document.getElementById('round-feedback-title');
  const detail = document.getElementById('round-feedback-detail');
  const score = document.getElementById('round-feedback-score');

  const scoreDelta = Number((result.scores || {})[playerId] || 0);
  const scoreText = `本轮得分变化：${formatScoreDelta(scoreDelta)} 分`;
  score.textContent = scoreText;
  score.classList.remove('text-green-300', 'text-red-300', 'text-purple-300');
  if (scoreDelta > 0) {
    score.classList.add('text-green-300');
  } else if (scoreDelta < 0) {
    score.classList.add('text-red-300');
  } else {
    score.classList.add('text-purple-300');
  }

  const subjectId = String(result.subject_id || '');
  const interrogatorId = String(result.interrogator_id || '');

  if (playerId === subjectId) {
    title.textContent = '你本轮作为被测者';
    if (!bonusScoringEnabled) {
      detail.textContent = `根据当前规则，被测者本轮不参与计分。${scoreText}`;
    } else if (scoreDelta === 50) {
      detail.textContent = `你使用 AI 回答骗过了所有陪审团，触发附加奖励。${scoreText}`;
    } else if (scoreDelta === 25) {
      detail.textContent = `你亲自回答骗过了所有陪审团，触发附加奖励。${scoreText}`;
    } else {
      detail.textContent = `附加给分机制已开启，但本轮未触发被测者奖励。${scoreText}`;
    }
    card.classList.remove('hidden');
    return;
  }

  const voteDetails = Array.isArray(result.vote_details) ? result.vote_details : [];
  const myVote = voteDetails.find((item) => item.voter_id === playerId);
  const voteValue = myVote ? myVote.vote : myLastVote;
  const voteLabel = voteValue === 'ai' ? 'AI' : voteValue === 'human' ? '真人' : '跳过';

  if (!voteValue) {
    title.textContent = '你本轮未提交投票';
    detail.textContent = scoreText;
  } else if (voteValue === 'skip') {
    title.textContent = '你本轮选择了跳过';
    detail.textContent = `你的判断：${voteLabel}。${scoreText}`;
  } else {
    const isCorrect = myVote ? Boolean(myVote.is_correct) : voteValue === result.subject_choice;
    const baseScore = isCorrect ? 50 : -30;
    const bonusScore = (playerId === interrogatorId && bonusScoringEnabled) ? scoreDelta - baseScore : 0;
    title.textContent = isCorrect ? '你本轮猜对了' : '你本轮猜错了';
    detail.textContent = `你的判断：${voteLabel}。${scoreText}`;
    if (bonusScore > 0) {
      detail.textContent += `（提问者附加奖励 +${bonusScore} 分）`;
    }
  }

  card.classList.remove('hidden');
}

// 复用全局 toast 事件，统一展示前台网络/提交异常提示。
function showGameToast(title, message, variant = 'error') {
  document.body.dispatchEvent(
    new CustomEvent('admin-toast', {
      detail: {
        title,
        message,
        variant,
      },
    }),
  );
}

// 解析后端 HTML 响应中的错误提示（兼容 200 + 红字错误块的接口约定）。
function parseHtmlErrorMessage(htmlText) {
  const rawText = String(htmlText || '');
  if (!rawText.trim()) return '';
  if (!rawText.includes('text-red-400')) return '';
  const container = document.createElement('div');
  container.innerHTML = rawText;
  return String(container.textContent || '').trim() || '请求失败';
}

// 拉取最新回合快照，用于提交失败后的“是否已生效”判定。
async function fetchRoundSnapshotForRecovery() {
  try {
    const requestFn = typeof window.requestWithRetry === 'function' ? window.requestWithRetry : fetch;
    const response = await requestFn(
      `/game/api/${roomId}/round`,
      { cache: 'no-store' },
      { timeoutMs: 5000, retries: 1 },
    );
    const payload = await response.json();
    if (payload.success && payload.round) {
      return payload.round;
    }
    return null;
  } catch (_error) {
    return null;
  }
}

// 提交关键动作并在失败后通过快照二次确认，避免“假失败/假成功”。
async function submitActionWithRecovery(options = {}) {
  const {
    url,
    body,
    method = 'POST',
    successVerifier = null,
  } = options;

  const requestFn = typeof window.requestWithRetry === 'function' ? window.requestWithRetry : fetch;

  try {
    const response = await requestFn(
      url,
      {
        method,
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body,
      },
      {
        timeoutMs: 6000,
        retries: 2,
      },
    );
    const text = await response.text();
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const htmlError = parseHtmlErrorMessage(text);
    if (htmlError) {
      throw new Error(htmlError);
    }
    return { success: true };
  } catch (error) {
    const snapshot = await fetchRoundSnapshotForRecovery();
    if (typeof successVerifier === 'function' && successVerifier(snapshot)) {
      return { success: true, recovered: true };
    }
    throw error;
  }
}

async function submitQuestion() {
  if (!currentRoundId) return;
  const input = document.getElementById('question-input');
  const question = input.value.trim();
  if (!question) return;

  lastQuestionDraft = question;
  await syncDraftNow('question', question);

  // 立即隐藏提问输入区域，防止重复点击
  document.getElementById('question-input-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交问题，等待被测者回答...';

  try {
    await submitActionWithRecovery({
      url: `/game/${roomId}/question`,
      body: `question=${encodeURIComponent(question)}&round_id=${encodeURIComponent(currentRoundId)}`,
      successVerifier: (snapshot) => {
        if (!snapshot) return false;
        const status = String(snapshot.status || '');
        const hasQuestion = Boolean(String(snapshot.question || '').trim());
        return hasQuestion || ['answering', 'voting', 'revealed'].includes(status);
      },
    });
    input.value = '';
  } catch (error) {
    showGameToast('提交失败', '提问提交失败，可重试', 'error');
    await initGameState({ silent: true, reason: 'question_submit_failed' });
    console.warn('submitQuestion failed:', error);
  }
}

// 显示得分规则弹窗
function showScoreRules() {
  document.getElementById('score-rules-modal').classList.remove('hidden');
}

// 隐藏得分规则弹窗
function hideScoreRules() {
  document.getElementById('score-rules-modal').classList.add('hidden');
}

// 点击弹窗背景关闭
document.addEventListener('click', function(e) {
  const modal = document.getElementById('score-rules-modal');
  if (e.target === modal) {
    hideScoreRules();
  }
});

function showHumanAnswer() {
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('answer-input-area').classList.remove('hidden');
  scheduleAnswerDraftSync();
}

async function submitAIAnswer() {
  if (!currentRoundId) return;
  // 立即隐藏选择区域，防止重复点击
  document.getElementById('answer-choice-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交回答，等待本阶段倒计时结束...';

  try {
    await submitActionWithRecovery({
      url: `/game/${roomId}/answer`,
      body: `answer_type=ai&answer_content=&round_id=${encodeURIComponent(currentRoundId)}`,
      successVerifier: (snapshot) => {
        if (!snapshot) return false;
        const status = String(snapshot.status || '');
        return Boolean(snapshot.is_answer_submitted) || ['voting', 'revealed'].includes(status);
      },
    });
  } catch (error) {
    showGameToast('提交失败', '回答提交失败，可重试', 'error');
    await initGameState({ silent: true, reason: 'ai_answer_submit_failed' });
    console.warn('submitAIAnswer failed:', error);
  }
}

async function submitHumanAnswer() {
  if (!currentRoundId) return;
  const input = document.getElementById('answer-input');
  const answer = input.value.trim();
  if (!answer) return;

  lastAnswerDraft = answer;
  await syncDraftNow('answer', answer);

  // 立即隐藏输入区域，防止重复点击
  document.getElementById('answer-input-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已提交回答，等待本阶段倒计时结束...';

  try {
    await submitActionWithRecovery({
      url: `/game/${roomId}/answer`,
      body: `answer_type=human&answer_content=${encodeURIComponent(answer)}&round_id=${encodeURIComponent(currentRoundId)}`,
      successVerifier: (snapshot) => {
        if (!snapshot) return false;
        const status = String(snapshot.status || '');
        return Boolean(snapshot.is_answer_submitted) || ['voting', 'revealed'].includes(status);
      },
    });
    input.value = '';
  } catch (error) {
    showGameToast('提交失败', '回答提交失败，可重试', 'error');
    await initGameState({ silent: true, reason: 'human_answer_submit_failed' });
    console.warn('submitHumanAnswer failed:', error);
  }
}

async function submitVote(vote) {
  if (!currentRoundId) return;
  myLastVote = vote;
  document.getElementById('vote-area').classList.add('hidden');
  document.getElementById('wait-area').classList.remove('hidden');
  document.getElementById('wait-area').querySelector('p').textContent = '已投票，等待其他玩家...';

  try {
    await submitActionWithRecovery({
      url: `/game/${roomId}/vote`,
      body: `vote=${vote}&round_id=${encodeURIComponent(currentRoundId)}`,
      successVerifier: (snapshot) => {
        if (!snapshot) return false;
        const status = String(snapshot.status || '');
        const myVote = String(snapshot.my_vote || '').trim();
        return Boolean(myVote) || status !== 'voting';
      },
    });
  } catch (error) {
    myLastVote = '';
    showGameToast('提交失败', '投票提交失败，可重试', 'error');
    await initGameState({ silent: true, reason: 'vote_submit_failed' });
    console.warn('submitVote failed:', error);
  }
}

// 当前玩家角色
let isCurrentInterrogator = false;
let isCurrentSubject = false;
let myNickname = '';

function redirectByRoomPhase(phase) {
  const normalized = String(phase || '').trim().toLowerCase();
  if (normalized === 'setup') {
    window.location.href = `/game/${roomId}/setup`;
    return true;
  }
  if (normalized === 'waiting') {
    window.location.href = `/game/${roomId}`;
    return true;
  }
  if (normalized === 'finished') {
    window.location.href = `/game/${roomId}/result`;
    return true;
  }
  return false;
}

function applyRoundSnapshot(round) {
  if (!round) return;
  applyRoundIdentity(round);

  const questionText = String(round.question || '').trim();
  const answerText = String(round.answer || '').trim();
  const isAnswerVisible = Boolean(round.is_answer_visible);
  const isAnswerSubmitted = Boolean(round.is_answer_submitted);
  const questionInput = document.getElementById('question-input');
  const answerInput = document.getElementById('answer-input');
  const loadingArea = document.getElementById('loading-area');
  const answerContent = document.getElementById('answer-content');

  document.getElementById('question-text').textContent = questionText || '等待提问...';

  if (questionInput) {
    const remoteQuestionDraft = String(round.my_question_draft || '');
    if (isCurrentInterrogator && round.status === 'questioning' && !questionText && remoteQuestionDraft && !questionInput.value.trim()) {
      questionInput.value = remoteQuestionDraft;
    }
    if (remoteQuestionDraft) {
      lastQuestionDraft = remoteQuestionDraft;
    }
  }

  if (answerInput) {
    const remoteAnswerDraft = String(round.my_answer_draft || '');
    if (isCurrentSubject && round.status === 'answering' && !isAnswerSubmitted && remoteAnswerDraft && !answerInput.value.trim()) {
      answerInput.value = remoteAnswerDraft;
    }
    if (remoteAnswerDraft) {
      lastAnswerDraft = remoteAnswerDraft;
    }
  }

  if (isAnswerVisible && answerText) {
    loadingArea.classList.add('hidden');
    answerContent.classList.remove('hidden');
    document.getElementById('answer-text').textContent = answerText;
    document.getElementById('answer-type-label').classList.add('hidden');
  } else {
    answerContent.classList.add('hidden');
    document.getElementById('answer-text').textContent = '等待回答...';
    if (round.status === 'answering' && (isAnswerSubmitted || !isCurrentSubject)) {
      loadingArea.classList.remove('hidden');
    } else {
      loadingArea.classList.add('hidden');
    }
  }

  updatePhaseDisplay(round.status);
  myLastVote = String(round.my_vote || '').trim();

  // 断线重连后若已提交回答/投票，强制回到等待态，避免继续展示可操作按钮。
  if (round.status === 'answering' && isCurrentSubject && isAnswerSubmitted) {
    document.getElementById('answer-choice-area').classList.add('hidden');
    document.getElementById('answer-input-area').classList.add('hidden');
    document.getElementById('wait-area').classList.remove('hidden');
    document.getElementById('wait-area').querySelector('p').textContent = '你已提交回答，等待本阶段结束...';
  }
  if (round.status === 'voting' && !isCurrentSubject && myLastVote) {
    document.getElementById('vote-area').classList.add('hidden');
    document.getElementById('wait-area').classList.remove('hidden');
    document.getElementById('wait-area').querySelector('p').textContent = '你已投票，等待其他玩家...';
  }
}

// 页面加载和重连后都调用该方法，确保丢失 SSE 事件时可以从服务端快照恢复 UI。
async function initGameState(options = {}) {
  const silent = Boolean(options?.silent);
  if (isSyncingGameState) return;
  isSyncingGameState = true;

  try {
    const requestFn = typeof window.requestWithRetry === 'function' ? window.requestWithRetry : fetch;
    const roomRes = await requestFn(
      `/game/api/${roomId}/state`,
      { cache: 'no-store' },
      { timeoutMs: 5000, retries: 1 },
    );
    const roomData = await roomRes.json();

    if (!roomData.success || !roomData.room) {
      if (!silent) {
        console.warn('房间状态恢复失败：', roomData.error || '未知错误');
      }
      return;
    }

    setRoundDisplay(roomData.room.current_round, roomData.room.total_rounds);
    if (redirectByRoomPhase(roomData.room.phase)) return;

    if (Array.isArray(roomData.players)) {
      const me = roomData.players.find((player) => player.id === playerId);
      if (me) {
        myNickname = String(me.nickname || '');
      }
      const playerScores = roomData.players.map((player) => ({
        id: player.id,
        nickname: player.nickname,
        score: player.score || 0,
      }));
      updateScoreBoard(playerScores);
    }

    const roundRes = await requestFn(
      `/game/api/${roomId}/round`,
      { cache: 'no-store' },
      { timeoutMs: 5000, retries: 1 },
    );
    const roundData = await roundRes.json();
    if (roundData.success && roundData.round) {
      applyRoundSnapshot(roundData.round);
      return;
    }

    if (redirectByRoomPhase(roundData.phase)) return;
    if (!silent) {
      console.warn('回合状态恢复失败：', roundData.error || '未知错误');
    }
  } catch (e) {
    if (!silent) {
      console.error('Failed to init game state:', e);
    }
  } finally {
    isSyncingGameState = false;
  }
}

// 回答区仅允许手动输入，禁止粘贴/拖拽注入文本（提问区不受影响）。
function lockAnswerInputPaste() {
  const answerInput = document.getElementById('answer-input');
  if (!answerInput) return;

  const blockPasteLikeInput = (event) => {
    const inputType = String(event.inputType || '');
    if (inputType === 'insertFromPaste' || inputType === 'insertFromDrop') {
      event.preventDefault();
    }
  };

  answerInput.addEventListener('beforeinput', blockPasteLikeInput);
  answerInput.addEventListener('paste', (event) => event.preventDefault());
  answerInput.addEventListener('drop', (event) => event.preventDefault());
  answerInput.addEventListener('keydown', (event) => {
    const key = String(event.key || '').toLowerCase();
    if ((event.ctrlKey || event.metaKey) && key === 'v') {
      event.preventDefault();
      return;
    }
    if (event.shiftKey && key === 'insert') {
      event.preventDefault();
    }
  });
}

function flushDraftOnBeforeUnload() {
  if (!currentRoundId || typeof navigator.sendBeacon !== 'function') return;
  const params = new URLSearchParams();
  if (isCurrentInterrogator && currentPhase === 'questioning') {
    const questionDraft = document.getElementById('question-input')?.value || '';
    if (questionDraft !== lastQuestionDraft) {
      params.set('round_id', currentRoundId);
      params.set('draft_type', 'question');
      params.set('content', questionDraft);
      navigator.sendBeacon(`/game/${roomId}/draft`, params);
      return;
    }
  }
  if (isCurrentSubject && currentPhase === 'answering') {
    const answerDraft = document.getElementById('answer-input')?.value || '';
    if (answerDraft !== lastAnswerDraft) {
      params.set('round_id', currentRoundId);
      params.set('draft_type', 'answer');
      params.set('content', answerDraft);
      navigator.sendBeacon(`/game/${roomId}/draft`, params);
    }
  }
}

function handleNetworkOnline() {
  setConnectionStatus('reconnecting', '网络已恢复，正在重连...');
  initGameState({ silent: true, reason: 'network_online' });
  forceReconnectSSE('network_online');
}

function handleNetworkOffline() {
  setConnectionStatus('offline', '网络断开，等待恢复');
  startStateSyncPolling();
}

function handlePageVisible() {
  if (document.hidden) return;
  initGameState({ silent: true, reason: 'page_visible' });
  if (!sseClient || !sseClient.isOpen()) {
    forceReconnectSSE('page_visible');
  }
}

// 页面加载时先获取状态，再连接 SSE
lockAnswerInputPaste();
document.getElementById('question-input').addEventListener('input', scheduleQuestionDraftSync);
document.getElementById('answer-input').addEventListener('input', scheduleAnswerDraftSync);
window.addEventListener('online', handleNetworkOnline);
window.addEventListener('offline', handleNetworkOffline);
document.addEventListener('visibilitychange', handlePageVisible);

setConnectionStatus(navigator.onLine ? 'reconnecting' : 'offline', navigator.onLine ? '初始化连接中...' : '网络断开，等待恢复');
initGameState({ reason: 'initial_load' }).then(() => {
  connectSSE('initial_load');
});

window.addEventListener('beforeunload', () => {
  flushDraftOnBeforeUnload();
  stopLocalCountdown();
  stopStateSyncPolling();
  stopSSEWatchdog();
  window.removeEventListener('online', handleNetworkOnline);
  window.removeEventListener('offline', handleNetworkOffline);
  document.removeEventListener('visibilitychange', handlePageVisible);
  if (sseClient) {
    sseClient.close();
    sseClient = null;
  }
});
</script>
{% endblock %}
