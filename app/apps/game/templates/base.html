<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="csrf-token" content="{{ request.state.csrf_token or '' }}" />
  <title>{% block title %}图灵测试游戏{% endblock %}</title>
  <link rel="stylesheet" href="/static/vendor/fontawesome/css/all.min.css" />
  <link rel="stylesheet" href="/static/css/app.css" />
  <script src="/static/js/game_network.js"></script>
  <script>
    window.__ttgBgmQueue = [];
    window.setGameBgmStage = function(stage, options) {
      window.__ttgBgmQueue.push({ stage, options: options || {} });
    };
  </script>
  <style>
    html, body {
      min-height: 100%;
      background-color: #0f172a;
      overscroll-behavior-x: none;
      overscroll-behavior-y: none;
    }
    body {
      min-height: 100dvh;
    }
    .input {
      @apply w-full rounded-lg border border-slate-600 bg-slate-800/50 px-4 py-2 text-white placeholder-slate-400 focus:border-purple-500 focus:outline-none focus:ring-2 focus:ring-purple-500/20;
    }
    .btn-primary {
      @apply rounded-lg bg-gradient-to-r from-purple-500 to-pink-500 px-4 py-2 font-medium text-white transition-all hover:from-purple-600 hover:to-pink-600 focus:outline-none focus:ring-2 focus:ring-purple-500/50;
    }
    .btn-secondary {
      @apply rounded-lg bg-slate-700 px-4 py-2 font-medium text-white transition-all hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-slate-500/50;
    }
  </style>
</head>

<body class="antialiased min-h-screen max-w-full overflow-x-hidden overscroll-none bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white">
  {% set soft_nav_enabled = enable_soft_nav | default(false, true) %}
  <main
    id="game-page-main"
    {% if soft_nav_enabled %}
    hx-boost="true"
    hx-push-url="true"
    hx-target="#game-page-main"
    hx-select="#game-page-main"
    hx-swap="outerHTML"
    {% endif %}
  >
    {% block content %}{% endblock %}
  </main>

  <audio id="game-bgm-player" preload="none" loop class="hidden"></audio>
  <div
    id="bgm-widget"
    class="fixed right-4 top-4 z-40 flex max-w-[calc(100vw-2rem)] flex-col items-end gap-2 select-none"
  >
    <div id="bgm-widget-toolbar" class="inline-flex items-center gap-1 rounded-full border border-white/20 bg-slate-900/70 px-2 py-1 text-[11px] text-purple-100 backdrop-blur">
      <button
        id="bgm-drag-handle"
        type="button"
        class="inline-flex h-6 w-6 touch-none items-center justify-center rounded-full text-purple-100 transition hover:bg-white/10"
        aria-label="拖动音乐面板"
        title="拖动音乐面板"
      >
        <i class="fa-solid fa-up-down-left-right"></i>
      </button>
      <button
        id="bgm-collapse-btn"
        type="button"
        class="inline-flex h-6 w-6 items-center justify-center rounded-full text-purple-100 transition hover:bg-white/10"
        aria-label="展开或收起音量面板"
        title="展开或收起音量面板"
      >
        <i class="fa-solid fa-chevron-up"></i>
      </button>
      <button
        id="bgm-hide-btn"
        type="button"
        class="inline-flex h-6 w-6 items-center justify-center rounded-full text-purple-100 transition hover:bg-white/10"
        aria-label="隐藏音乐面板"
        title="隐藏音乐面板"
      >
        <i class="fa-solid fa-eye-slash"></i>
      </button>
    </div>
    <button
      id="bgm-toggle-btn"
      type="button"
      class="inline-flex items-center gap-2 rounded-full border border-white/20 bg-slate-900/70 px-3 py-2 text-xs text-white backdrop-blur transition hover:bg-slate-800/80"
      aria-label="切换背景音乐"
    >
      <i class="fa-solid fa-volume-xmark"></i>
      <span>音乐关闭</span>
    </button>
    <div
      id="bgm-volume-panel"
      class="w-44 rounded-xl border border-white/15 bg-slate-900/70 px-3 py-2 text-white backdrop-blur"
      aria-label="背景音乐音量设置"
    >
      <div class="flex items-center justify-between text-[11px] text-purple-100/90">
        <span>音乐音量</span>
        <span id="bgm-volume-text">60%</span>
      </div>
      <div class="mt-1 flex items-center gap-2">
        <i class="fa-solid fa-volume-low text-xs text-purple-100/80" aria-hidden="true"></i>
        <input
          id="bgm-volume-range"
          type="range"
          min="0"
          max="100"
          step="1"
          value="60"
          class="h-1.5 w-full cursor-pointer accent-purple-400"
          aria-label="设置背景音乐音量"
        />
      </div>
    </div>
  </div>
  <button
    id="bgm-show-btn"
    type="button"
    class="fixed right-4 top-4 z-40 hidden touch-none rounded-full border border-white/20 bg-slate-900/70 px-3 py-2 text-xs text-white backdrop-blur transition hover:bg-slate-800/80"
    aria-label="显示音乐面板"
  >
    <i class="fa-solid fa-music mr-1"></i>
    <span>音乐面板</span>
  </button>

  {% set footer_text = request.state.footer_copyright_text | default("TuringTestGame", true) %}
  {% set footer_url = request.state.footer_copyright_url | default("https://github.com/xy3xy3/TuringTestGame", true) %}
  <footer class="px-4 pb-6 pt-2">
    <div class="mx-auto max-w-4xl rounded-xl border border-white/10 bg-white/10 backdrop-blur-sm">
      {% if footer_url %}
        <a
          href="{{ footer_url }}"
          target="_blank"
          rel="noopener noreferrer"
          class="flex items-center justify-center gap-2 px-4 py-3 text-sm text-purple-100 transition-colors hover:text-white"
        >
          <i class="fa-brands fa-github text-base"></i>
          <span>开源项目：{{ footer_text }}</span>
          <span class="text-xs text-purple-200/80">点击查看</span>
        </a>
      {% else %}
        <div class="flex items-center justify-center gap-2 px-4 py-3 text-sm text-purple-100">
          <i class="fa-solid fa-bullhorn text-base"></i>
          <span>开源项目：{{ footer_text }}</span>
        </div>
      {% endif %}
    </div>
  </footer>

  <div id="toast" data-variant="success" class="toast">
    <div class="toast-body">
      <div class="toast-dot"></div>
      <div>
        <p data-toast-title class="toast-title">操作完成</p>
        <p data-toast-message class="toast-message">已成功提交变更</p>
      </div>
    </div>
  </div>

  <div id="global-indicator"
    class="htmx-indicator fixed bottom-6 right-6 z-40 rounded-md border border-slate-200 bg-white px-3 py-2 text-xs font-medium text-slate-500 shadow-ink">
    正在处理...
  </div>

  <script src="/static/vendor/htmx.min.js" defer></script>
  <script src="/static/vendor/alpine.js" defer></script>
  <script src="/static/js/app.js" defer></script>
  <script>
    (() => {
      const NICKNAME_STORAGE_KEY = "ttg_player_nickname";

      // 读取并清洗本地昵称，只接受 2~32 字符的有效值。
      const getStoredNickname = () => {
        const value = window.localStorage.getItem(NICKNAME_STORAGE_KEY);
        const nickname = String(value || "").trim();
        if (nickname.length < 2 || nickname.length > 32) return "";
        return nickname;
      };

      // 将昵称持久化到 localStorage，便于后续页面自动回填。
      const persistNickname = (value) => {
        const nickname = String(value || "").trim();
        if (nickname.length < 2 || nickname.length > 32) return;
        window.localStorage.setItem(NICKNAME_STORAGE_KEY, nickname);
      };

      // 给页面中的昵称输入框自动回填，并触发 input 以同步 Alpine/校验状态。
      const hydrateNicknameInputs = (root) => {
        const nickname = getStoredNickname();
        if (!nickname) return;
        const host = root instanceof HTMLElement || root instanceof Document ? root : document;
        const inputs = host.querySelectorAll('input[name="nickname"]:not([type="hidden"])');
        inputs.forEach((input) => {
          if (!(input instanceof HTMLInputElement)) return;
          if (String(input.value || "").trim()) return;
          input.value = nickname;
          input.dispatchEvent(new Event("input", { bubbles: true }));
        });
      };

      document.addEventListener("input", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        if (target.name !== "nickname" || target.type === "hidden") return;
        persistNickname(target.value);
      });

      document.addEventListener("submit", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLFormElement)) return;
        const nicknameInput = target.querySelector('input[name="nickname"]');
        if (!(nicknameInput instanceof HTMLInputElement)) return;
        persistNickname(nicknameInput.value);
      }, true);

      // 先回填一次，覆盖普通页面和首屏渲染场景。
      hydrateNicknameInputs(document);

      // Alpine 初始化后再回填一次，避免 x-model 首次渲染重置输入值。
      document.addEventListener("alpine:initialized", () => {
        hydrateNicknameInputs(document);
      });

      // HTMX 局部刷新后对新节点再次回填昵称。
      document.addEventListener("htmx:afterSwap", (event) => {
        const target = event.target;
        if (target instanceof HTMLElement) {
          hydrateNicknameInputs(target);
          return;
        }
        hydrateNicknameInputs(document);
      });
    })();
  </script>
  <script>
    (() => {
      // 注册当前页面的清理回调，供软导航切页前释放 SSE/定时器等资源。
      let activePageCleanup = null;

      window.registerGamePageCleanup = (cleanupFn) => {
        if (typeof cleanupFn !== "function") {
          activePageCleanup = null;
          return;
        }
        activePageCleanup = cleanupFn;
      };

      window.runGamePageCleanup = (reason = "manual") => {
        if (typeof activePageCleanup !== "function") return;
        const cleanup = activePageCleanup;
        activePageCleanup = null;
        try {
          cleanup(reason);
        } catch (error) {
          console.warn("game page cleanup failed:", error);
        }
      };

      // 统一前台路由跳转：优先 HTMX 软导航，失败时降级为硬跳转。
      window.ttgNavigate = (path, options = {}) => {
        const nextPath = String(path || "").trim();
        if (!nextPath) return false;
        const mainEl = document.getElementById("game-page-main");
        const canSoftNavigate = Boolean(
          typeof window.htmx !== "undefined"
          && mainEl
          && mainEl.hasAttribute("hx-boost")
          && options.soft !== false
        );
        if (canSoftNavigate) {
          try {
            window.htmx.ajax("GET", nextPath, {
              target: "#game-page-main",
              swap: "outerHTML",
              select: "#game-page-main",
              push: nextPath,
            });
            return true;
          } catch (error) {
            console.warn("soft navigate failed, fallback to hard reload:", error);
          }
        }
        window.location.href = nextPath;
        return false;
      };

      document.body.addEventListener("htmx:beforeSwap", (event) => {
        const target = event.detail?.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.id !== "game-page-main") return;
        window.runGamePageCleanup("before_swap");
      });

      window.addEventListener("beforeunload", () => {
        window.runGamePageCleanup("before_unload");
      });
    })();
  </script>
  <script>
    (() => {
      const tracks = {{ request.state.game_bgm_config | default({}, true) | tojson }};
      const initialStage = {{ bgm_stage | default("", true) | tojson }};
      const audioEl = document.getElementById("game-bgm-player");
      const widgetEl = document.getElementById("bgm-widget");
      const toggleBtn = document.getElementById("bgm-toggle-btn");
      const volumePanel = document.getElementById("bgm-volume-panel");
      const volumeRange = document.getElementById("bgm-volume-range");
      const volumeText = document.getElementById("bgm-volume-text");
      const collapseBtn = document.getElementById("bgm-collapse-btn");
      const hideBtn = document.getElementById("bgm-hide-btn");
      const showBtn = document.getElementById("bgm-show-btn");
      const dragHandle = document.getElementById("bgm-drag-handle");
      const dragToolbar = document.getElementById("bgm-widget-toolbar");
      if (!audioEl || !widgetEl || !toggleBtn || !volumePanel || !volumeRange || !volumeText || !collapseBtn || !hideBtn || !showBtn || !dragHandle || !dragToolbar) return;

      const iconEl = toggleBtn.querySelector("i");
      const textEl = toggleBtn.querySelector("span");
      const collapseIconEl = collapseBtn.querySelector("i");
      let enabled = window.localStorage.getItem("ttg_bgm_enabled") !== "0";
      let isCollapsed = window.localStorage.getItem("ttg_bgm_widget_collapsed") === "1";
      let isHidden = window.localStorage.getItem("ttg_bgm_widget_hidden") === "1";
      // 将本地存储值统一归一化为 0~1，兼容历史百分比存储值。
      const normalizeVolume = (rawValue) => {
        const parsed = Number(rawValue);
        if (!Number.isFinite(parsed)) return 0.6;
        if (parsed > 1) {
          if (parsed <= 100) {
            return Math.max(0, Math.min(1, parsed / 100));
          }
          return 0.6;
        }
        return Math.max(0, Math.min(1, parsed));
      };
      let volume = normalizeVolume(window.localStorage.getItem("ttg_bgm_volume"));
      let currentStage = "";
      let pendingUserGesture = false;
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let activePointerId = null;
      let dragMode = "widget";
      let dragStartClientX = 0;
      let dragStartClientY = 0;
      let suppressShowClickOnce = false;
      const defaultPosition = { right: 16, top: 16 };
      const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
      const BGM_PROGRESS_STORAGE_KEY = "ttg_bgm_progress_state_v1";
      const BGM_PROGRESS_MAX_AGE_MS = 30 * 60 * 1000;
      const BGM_PROGRESS_SAVE_INTERVAL_MS = 1500;

      // 统一把相对路径/绝对路径转成可比较的完整 URL，避免同曲目误判成“不同来源”。
      const normalizeTrackUrl = (rawUrl) => {
        const value = String(rawUrl || "").trim();
        if (!value) return "";
        try {
          return new URL(value, window.location.origin).href;
        } catch {
          return value;
        }
      };

      // 仅在当前标签页内存储播放进度，避免多标签页互相覆盖。
      const getBgmProgressStorage = () => {
        try {
          return window.sessionStorage;
        } catch {
          return null;
        }
      };

      // 读取最近一次背景音乐播放快照。
      const readBgmProgressSnapshot = () => {
        const storage = getBgmProgressStorage();
        if (!storage) return null;
        const raw = storage.getItem(BGM_PROGRESS_STORAGE_KEY);
        if (!raw) return null;
        try {
          const parsed = JSON.parse(raw);
          const src = normalizeTrackUrl(parsed.src);
          const time = Number(parsed.time);
          const ts = Number(parsed.ts);
          if (!src || !Number.isFinite(time) || time < 0 || !Number.isFinite(ts) || ts <= 0) {
            return null;
          }
          return {
            src,
            time,
            ts,
            wasPlaying: Boolean(parsed.wasPlaying),
          };
        } catch {
          return null;
        }
      };

      // 记录当前曲目播放进度，供跨页面切换时续播。
      const saveBgmProgressSnapshot = () => {
        const storage = getBgmProgressStorage();
        if (!storage) return;
        const src = normalizeTrackUrl(audioEl.getAttribute("src") || audioEl.currentSrc);
        if (!src) return;
        const currentTime = Number(audioEl.currentTime);
        if (!Number.isFinite(currentTime) || currentTime < 0) return;
        const snapshot = {
          src,
          time: currentTime,
          ts: Date.now(),
          wasPlaying: !audioEl.paused && !audioEl.ended,
        };
        storage.setItem(BGM_PROGRESS_STORAGE_KEY, JSON.stringify(snapshot));
      };

      // 命中同一曲目时计算恢复时间；若切页期间本来在播放，则按真实流逝时间补偿进度。
      const resolveResumeTimeForTrack = (normalizedSrc) => {
        if (!normalizedSrc) return null;
        const snapshot = readBgmProgressSnapshot();
        if (!snapshot || snapshot.src !== normalizedSrc) return null;
        const ageMs = Date.now() - snapshot.ts;
        if (!Number.isFinite(ageMs) || ageMs < 0 || ageMs > BGM_PROGRESS_MAX_AGE_MS) return null;
        let nextTime = snapshot.time;
        if (snapshot.wasPlaying) {
          nextTime += ageMs / 1000;
        }
        return nextTime >= 0 ? nextTime : null;
      };

      // 在音频元数据可用后设置 currentTime，确保恢复进度在各浏览器都稳定生效。
      const seekBgmTime = (targetTime) => {
        if (!Number.isFinite(targetTime) || targetTime < 0) return;
        const applySeek = () => {
          let nextTime = targetTime;
          const duration = Number(audioEl.duration);
          if (Number.isFinite(duration) && duration > 0) {
            nextTime %= duration;
          }
          try {
            audioEl.currentTime = Math.max(0, nextTime);
          } catch {
            // 某些浏览器在音频尚未就绪时会抛错，忽略即可。
          }
        };
        if (audioEl.readyState >= 1) {
          applySeek();
          return;
        }
        audioEl.addEventListener("loadedmetadata", applySeek, { once: true });
      };

      // 读取持久化坐标，异常值自动忽略，防止面板丢失到可视区域外。
      const readStoredPosition = () => {
        const raw = window.localStorage.getItem("ttg_bgm_widget_pos");
        if (!raw) return null;
        try {
          const parsed = JSON.parse(raw);
          const left = Number(parsed.left);
          const top = Number(parsed.top);
          if (!Number.isFinite(left) || !Number.isFinite(top)) return null;
          return { left, top };
        } catch {
          return null;
        }
      };

      const applyAbsolutePosition = (element, left, top) => {
        element.style.left = `${left}px`;
        element.style.top = `${top}px`;
        element.style.right = "auto";
      };

      // 将悬浮控件定位到指定坐标，且保证不超出屏幕边界。
      const applyFloatingPosition = (left, top, persist = false, mode = "widget") => {
        const targetEl = mode === "show" ? showBtn : widgetEl;
        const rect = targetEl.getBoundingClientRect();
        const maxLeft = Math.max(0, window.innerWidth - rect.width);
        const maxTop = Math.max(0, window.innerHeight - rect.height);
        const nextLeft = clamp(Math.round(left), 0, maxLeft);
        const nextTop = clamp(Math.round(top), 0, maxTop);
        applyAbsolutePosition(widgetEl, nextLeft, nextTop);
        applyAbsolutePosition(showBtn, nextLeft, nextTop);
        if (persist) {
          window.localStorage.setItem("ttg_bgm_widget_pos", JSON.stringify({ left: nextLeft, top: nextTop }));
        }
      };

      // 首次加载时恢复拖拽坐标，若无记录则使用右上角默认位置。
      const restoreWidgetPosition = () => {
        const stored = readStoredPosition();
        if (stored) {
          applyFloatingPosition(stored.left, stored.top);
          return;
        }
        widgetEl.style.left = "auto";
        widgetEl.style.right = `${defaultPosition.right}px`;
        widgetEl.style.top = `${defaultPosition.top}px`;
        showBtn.style.left = "auto";
        showBtn.style.right = `${defaultPosition.right}px`;
        showBtn.style.top = `${defaultPosition.top}px`;
      };

      // 根据隐藏状态刷新显示，隐藏后保留一个轻量按钮方便快速恢复。
      const applyHiddenState = () => {
        widgetEl.classList.toggle("hidden", isHidden);
        showBtn.classList.toggle("hidden", !isHidden);
        window.localStorage.setItem("ttg_bgm_widget_hidden", isHidden ? "1" : "0");
      };

      // 根据收起状态刷新音量区域，避免遮挡回合信息。
      const applyCollapsedState = () => {
        volumePanel.classList.toggle("hidden", isCollapsed);
        if (collapseIconEl) {
          collapseIconEl.className = isCollapsed ? "fa-solid fa-chevron-down" : "fa-solid fa-chevron-up";
        }
        window.localStorage.setItem("ttg_bgm_widget_collapsed", isCollapsed ? "1" : "0");
      };

      // 同步播放器实际音量，确保切歌后也沿用当前设置。
      const applyVolume = () => {
        audioEl.volume = volume;
      };

      // 刷新音量滑块和百分比显示。
      const updateVolumeUi = () => {
        const percent = Math.round(volume * 100);
        volumeRange.value = String(percent);
        volumeText.textContent = `${percent}%`;
      };

      const updateToggleUi = () => {
        if (iconEl) {
          if (!enabled) {
            iconEl.className = "fa-solid fa-volume-xmark";
          } else if (volume < 0.5) {
            iconEl.className = "fa-solid fa-volume-low";
          } else {
            iconEl.className = "fa-solid fa-volume-high";
          }
        }
        if (textEl) {
          textEl.textContent = enabled ? "音乐开启" : "音乐关闭";
        }
      };

      const tryPlayCurrent = () => {
        if (!enabled || !audioEl.src) return;
        const playPromise = audioEl.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch(() => {
            // 自动播放受限时等待用户手势再次触发播放。
            pendingUserGesture = true;
          });
        }
      };

      const applyStage = (stage, options = {}) => {
        const nextStage = String(stage || "").trim();
        const nextSrc = nextStage ? String(tracks[nextStage] || "").trim() : "";
        const normalizedNextSrc = normalizeTrackUrl(nextSrc);
        const forceRestart = Boolean(options.forceRestart);
        currentStage = nextStage;
        if (!nextSrc) {
          saveBgmProgressSnapshot();
          audioEl.pause();
          audioEl.removeAttribute("src");
          audioEl.load();
          return;
        }
        const currentSrc = normalizeTrackUrl(audioEl.getAttribute("src") || audioEl.currentSrc);
        if (currentSrc !== normalizedNextSrc) {
          saveBgmProgressSnapshot();
          audioEl.setAttribute("src", nextSrc);
          audioEl.load();
          if (!forceRestart) {
            const resumeTime = resolveResumeTimeForTrack(normalizedNextSrc);
            if (resumeTime !== null) {
              seekBgmTime(resumeTime);
            }
          }
        } else if (forceRestart) {
          seekBgmTime(0);
        }
        applyVolume();
        tryPlayCurrent();
      };

      window.setGameBgmStage = (stage, options) => {
        applyStage(stage, options || {});
      };

      toggleBtn.addEventListener("click", () => {
        enabled = !enabled;
        window.localStorage.setItem("ttg_bgm_enabled", enabled ? "1" : "0");
        updateToggleUi();
        if (!enabled) {
          audioEl.pause();
          return;
        }
        pendingUserGesture = false;
        tryPlayCurrent();
      });

      volumeRange.addEventListener("input", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) return;
        volume = normalizeVolume(Number(target.value) / 100);
        window.localStorage.setItem("ttg_bgm_volume", volume.toFixed(2));
        applyVolume();
        updateVolumeUi();
        updateToggleUi();
        // 调整音量属于用户手势，可尝试恢复受限的自动播放。
        if (enabled) {
          pendingUserGesture = false;
          tryPlayCurrent();
        }
      });

      const onUserGesture = () => {
        if (!pendingUserGesture || !enabled) return;
        pendingUserGesture = false;
        tryPlayCurrent();
      };

      // 拖拽开始：记录鼠标与面板左上角偏移，后续移动即可平滑跟手。
      const startDrag = (clientX, clientY, mode = "widget") => {
        dragMode = mode;
        const targetEl = mode === "show" ? showBtn : widgetEl;
        const rect = targetEl.getBoundingClientRect();
        dragOffsetX = clientX - rect.left;
        dragOffsetY = clientY - rect.top;
        dragStartClientX = clientX;
        dragStartClientY = clientY;
        isDragging = true;
      };

      // 拖拽进行中：持续更新面板坐标并实时裁剪到可视区域。
      const moveDrag = (clientX, clientY) => {
        if (!isDragging) return;
        const movedX = Math.abs(clientX - dragStartClientX);
        const movedY = Math.abs(clientY - dragStartClientY);
        if (movedX >= 3 || movedY >= 3) {
          suppressShowClickOnce = dragMode === "show";
        }
        applyFloatingPosition(clientX - dragOffsetX, clientY - dragOffsetY, false, dragMode);
      };

      // 拖拽结束：写入 localStorage，刷新后仍保留用户上次摆放位置。
      const stopDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        const targetEl = dragMode === "show" ? showBtn : widgetEl;
        const rect = targetEl.getBoundingClientRect();
        applyFloatingPosition(rect.left, rect.top, true, dragMode);
      };

      // 使用全局 pointermove/pointerup 兜底，避免移动端 setPointerCapture 失效时“缩小后无法拖动”。
      const onWindowPointerMove = (event) => {
        if (!(event instanceof PointerEvent)) return;
        if (!isDragging || (activePointerId !== null && event.pointerId !== activePointerId)) return;
        moveDrag(event.clientX, event.clientY);
        event.preventDefault();
      };
      const onWindowPointerUp = (event) => {
        if (!(event instanceof PointerEvent)) return;
        if (!isDragging || (activePointerId !== null && event.pointerId !== activePointerId)) return;
        stopDrag();
        activePointerId = null;
      };

      const beginDragByPointerEvent = (event, mode = "widget") => {
        if (!(event instanceof PointerEvent)) return;
        if (event.button !== undefined && event.button !== 0) return;
        activePointerId = event.pointerId;
        startDrag(event.clientX, event.clientY, mode);
        try {
          const captureTarget = event.target instanceof Element ? event.target : dragToolbar;
          if ("setPointerCapture" in captureTarget && typeof captureTarget.setPointerCapture === "function") {
            captureTarget.setPointerCapture(event.pointerId);
          }
        } catch {
          // 某些浏览器可能不支持指针捕获，这里忽略即可。
        }
        if (mode === "widget") {
          event.preventDefault();
        }
      };

      dragToolbar.addEventListener("pointerdown", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        if (target.closest("#bgm-collapse-btn") || target.closest("#bgm-hide-btn")) return;
        beginDragByPointerEvent(event, "widget");
      });
      showBtn.addEventListener("pointerdown", (event) => {
        beginDragByPointerEvent(event, "show");
      });
      window.addEventListener("pointermove", onWindowPointerMove, { passive: false });
      window.addEventListener("pointerup", onWindowPointerUp);
      window.addEventListener("pointercancel", onWindowPointerUp);

      collapseBtn.addEventListener("click", () => {
        isCollapsed = !isCollapsed;
        applyCollapsedState();
      });
      hideBtn.addEventListener("click", () => {
        isHidden = true;
        applyHiddenState();
      });
      showBtn.addEventListener("click", (event) => {
        if (suppressShowClickOnce) {
          suppressShowClickOnce = false;
          event.preventDefault();
          return;
        }
        isHidden = false;
        applyHiddenState();
      });
      window.addEventListener("resize", () => {
        const rect = isHidden ? showBtn.getBoundingClientRect() : widgetEl.getBoundingClientRect();
        const hasCustomPosition = Boolean(widgetEl.style.left || showBtn.style.left);
        if (hasCustomPosition) {
          applyFloatingPosition(rect.left, rect.top, true, isHidden ? "show" : "widget");
        }
      });

      window.addEventListener("pointerdown", onUserGesture, { passive: true });
      window.addEventListener("keydown", onUserGesture, { passive: true });
      window.addEventListener("beforeunload", saveBgmProgressSnapshot);
      window.addEventListener("pagehide", saveBgmProgressSnapshot);
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          saveBgmProgressSnapshot();
        }
      });
      audioEl.addEventListener("pause", saveBgmProgressSnapshot);
      audioEl.addEventListener("ended", saveBgmProgressSnapshot);
      window.setInterval(saveBgmProgressSnapshot, BGM_PROGRESS_SAVE_INTERVAL_MS);

      restoreWidgetPosition();
      applyHiddenState();
      applyCollapsedState();
      applyVolume();
      updateVolumeUi();
      updateToggleUi();

      // 先处理页面设置的默认阶段。
      if (initialStage) {
        applyStage(initialStage);
      }

      // 再处理内容区脚本在加载早期推入的阶段切换请求。
      const queued = Array.isArray(window.__ttgBgmQueue) ? window.__ttgBgmQueue : [];
      while (queued.length) {
        const item = queued.shift();
        if (item && item.stage !== undefined) {
          applyStage(item.stage, item.options || {});
        }
      }
    })();
  </script>
  {% block scripts %}{% endblock %}
</body>

</html>
